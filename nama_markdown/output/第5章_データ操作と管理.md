
================================================================================

# 26. データ挿入：INSERT文

## はじめに

これまでの章では、SELECT文を中心としたデータの検索と分析について詳しく学んできました。第5章からは、データベースの操作と管理について学習します。最初に取り上げるのは「INSERT文」です。

INSERT文は、データベースのテーブルに新しいレコード（行）を追加するためのSQL文です。これまで学習で使用してきた学校データベースのサンプルデータも、すべてINSERT文によって作成されています。

INSERT文が必要となる場面の例：
- 「新しい学生が入学したので、学生情報を登録したい」
- 「新学期の講座スケジュールをまとめて登録したい」
- 「他のシステムからデータを移行したい」
- 「テスト用のサンプルデータを作成したい」
- 「ユーザーが入力したフォームデータを保存したい」

この章では、INSERT文の基本構文から、実践的な活用方法、注意点まで詳しく学んでいきます。

## INSERT文とは

INSERT文は、テーブルに新しいデータ行を追加するためのSQL文です。データベースの基本操作であるCRUD（Create、Read、Update、Delete）の「Create」に該当します。

> **用語解説**：
> - **INSERT文**：テーブルに新しいレコード（行）を挿入するSQL文です。
> - **VALUES句**：挿入する具体的な値を指定する部分です。
> - **カラムリスト**：データを挿入する対象のカラムを明示的に指定するリストです。
> - **一括挿入**：複数のレコードを一度のINSERT文で挿入することです。
> - **INSERT SELECT**：他のテーブルから取得したデータを新しいテーブルに挿入する方法です。
> - **デフォルト値**：カラムに値が指定されなかった場合に自動的に設定される値です。

## INSERT文の基本構文

### 1. 基本的なINSERT構文

```sql
INSERT INTO テーブル名 (カラム1, カラム2, カラム3, ...)
VALUES (値1, 値2, 値3, ...);
```

### 2. カラム名を省略した構文

```sql
INSERT INTO テーブル名
VALUES (値1, 値2, 値3, ...);
```

カラム名を省略する場合は、テーブル定義の順序通りにすべてのカラムに対して値を指定する必要があります。

## 基本的なINSERT文の例

### 例1：新しい学生の登録

```sql
-- カラムを明示的に指定したINSERT
INSERT INTO students (student_id, student_name)
VALUES (326, '山田太郎');
```

このクエリでは、studentsテーブルに学生ID=326、学生名='山田太郎'の新しい学生を追加しています。

### 例2：新しい教師の登録

```sql
-- すべてのカラムに値を指定
INSERT INTO teachers (teacher_id, teacher_name)
VALUES (109, '佐藤花子');
```

### 例3：新しい講座の登録

```sql
-- 一部のカラムのみに値を指定（他はNULLまたはデフォルト値）
INSERT INTO courses (course_id, course_name, teacher_id)
VALUES ('30', '新しいプログラミング講座', 109);
```

実行後の確認：

```sql
-- 挿入されたデータの確認
SELECT * FROM students WHERE student_id = 326;
SELECT * FROM teachers WHERE teacher_id = 109;
SELECT * FROM courses WHERE course_id = '30';
```

## 複数行の一括挿入

一度のINSERT文で複数のレコードを挿入することができます。これはパフォーマンスの面で効率的です。

### 例4：複数の学生を一括登録

```sql
INSERT INTO students (student_id, student_name)
VALUES 
    (327, '鈴木一郎'),
    (328, '田中美咲'),
    (329, '高橋健太'),
    (330, '伊藤愛子');
```

### 例5：複数の教室を一括登録

```sql
INSERT INTO classrooms (classroom_id, classroom_name, capacity, building, facilities)
VALUES 
    ('501A', '501A講義室', 80, '5号館', 'プロジェクター、ホワイトボード'),
    ('501B', '501Bセミナー室', 30, '5号館', 'ホワイトボード、可動式机'),
    ('502', '502コンピュータ実習室', 40, '5号館', 'PC40台、プロジェクター');
```

実行後の確認：

```sql
-- 挿入された複数のレコードを確認
SELECT * FROM students WHERE student_id BETWEEN 327 AND 330;
SELECT * FROM classrooms WHERE building = '5号館';
```

## INSERT SELECT文

他のテーブルやビューから取得したデータを新しいテーブルに挿入する場合に使用します。

### 基本構文

```sql
INSERT INTO 挿入先テーブル (カラム1, カラム2, ...)
SELECT カラム1, カラム2, ...
FROM 参照元テーブル
WHERE 条件;
```

### 例6：優秀な学生のリストを別テーブルに作成

まず、優秀な学生を格納するテーブルを作成：

```sql
-- 優秀学生テーブルの作成（実際のデータベース操作では必要）
CREATE TABLE excellent_students (
    student_id BIGINT PRIMARY KEY,
    student_name VARCHAR(64),
    avg_score DECIMAL(5,2),
    registration_date DATE DEFAULT (CURRENT_DATE)
);
```

平均点が85点以上の学生を抽出して新しいテーブルに挿入：

```sql
INSERT INTO excellent_students (student_id, student_name, avg_score)
SELECT 
    s.student_id,
    s.student_name,
    ROUND(AVG(g.score), 2)
FROM students s
JOIN grades g ON s.student_id = g.student_id
GROUP BY s.student_id, s.student_name
HAVING AVG(g.score) >= 85;
```

### 例7：月次出席レポートテーブルの作成

```sql
-- 月次出席レポートテーブルの作成
CREATE TABLE monthly_attendance_report (
    report_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    student_id BIGINT,
    student_name VARCHAR(64),
    month_year VARCHAR(7),
    total_classes INT,
    present_count INT,
    attendance_rate DECIMAL(5,2),
    report_date DATE DEFAULT (CURRENT_DATE)
);

-- 2025年5月の出席データを挿入
INSERT INTO monthly_attendance_report 
    (student_id, student_name, month_year, total_classes, present_count, attendance_rate)
SELECT 
    s.student_id,
    s.student_name,
    '2025-05' AS month_year,
    COUNT(a.schedule_id) AS total_classes,
    SUM(CASE WHEN a.status = 'present' THEN 1 ELSE 0 END) AS present_count,
    ROUND(AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END), 2) AS attendance_rate
FROM students s
JOIN attendance a ON s.student_id = a.student_id
JOIN course_schedule cs ON a.schedule_id = cs.schedule_id
WHERE cs.schedule_date BETWEEN '2025-05-01' AND '2025-05-31'
GROUP BY s.student_id, s.student_name
HAVING COUNT(a.schedule_id) > 0;
```

## NULL値とデフォルト値の扱い

### NULL値の明示的な挿入

```sql
-- NULLを明示的に指定
INSERT INTO teacher_unavailability (teacher_id, start_date, end_date, reason)
VALUES (101, '2025-06-01', '2025-06-03', NULL);
```

### デフォルト値の使用

```sql
-- DEFAULTキーワードを使用
INSERT INTO course_schedule (course_id, schedule_date, period_id, classroom_id, teacher_id, status)
VALUES ('1', '2025-06-10', 1, '101A', 101, DEFAULT);
```

### カラムの省略によるデフォルト値の使用

```sql
-- statusカラムを省略（デフォルト値'scheduled'が設定される）
INSERT INTO course_schedule (course_id, schedule_date, period_id, classroom_id, teacher_id)
VALUES ('1', '2025-06-11', 2, '101A', 101);
```

## 条件付きINSERT

### INSERT IGNORE

重複キーエラーを無視して挿入を続行します：

```sql
-- 既存の学生IDが存在してもエラーにしない
INSERT IGNORE INTO students (student_id, student_name)
VALUES (301, '既存学生'), (331, '新規学生');
```

### ON DUPLICATE KEY UPDATE

重複が発生した場合に更新を実行します：

```sql
-- 学生IDが重複した場合は名前を更新
INSERT INTO students (student_id, student_name)
VALUES (301, '更新された名前')
ON DUPLICATE KEY UPDATE student_name = VALUES(student_name);
```

## 実践的なINSERT例

### 例8：新学期の授業スケジュール一括登録

```sql
-- 新しい講座の登録
INSERT INTO courses (course_id, course_name, teacher_id)
VALUES ('31', 'データサイエンス応用', 106);

-- 学生の受講登録
INSERT INTO student_courses (course_id, student_id)
SELECT '31', student_id
FROM students
WHERE student_id BETWEEN 301 AND 310;

-- 授業スケジュールの登録（6月の毎週水曜日）
INSERT INTO course_schedule (course_id, schedule_date, period_id, classroom_id, teacher_id)
VALUES 
    ('31', '2025-06-04', 3, '402H', 106),
    ('31', '2025-06-11', 3, '402H', 106),
    ('31', '2025-06-18', 3, '402H', 106),
    ('31', '2025-06-25', 3, '402H', 106);
```

### 例9：出席データの一括登録

```sql
-- 特定の授業に対する出席データを一括登録
INSERT INTO attendance (schedule_id, student_id, status)
SELECT 
    cs.schedule_id,
    sc.student_id,
    CASE 
        WHEN sc.student_id % 10 = 0 THEN 'absent'
        WHEN sc.student_id % 7 = 0 THEN 'late'
        ELSE 'present'
    END AS status
FROM course_schedule cs
JOIN student_courses sc ON cs.course_id = sc.course_id
WHERE cs.schedule_date = '2025-06-04' AND cs.course_id = '31';
```

### 例10：成績データの段階的登録

```sql
-- 中間テストの成績を登録
INSERT INTO grades (student_id, course_id, grade_type, score, max_score, submission_date)
SELECT 
    sc.student_id,
    '31',
    '中間テスト',
    ROUND(70 + (RAND() * 30), 1),  -- 70-100点のランダムな点数
    100,
    '2025-06-15'
FROM student_courses sc
WHERE sc.course_id = '31';

-- レポート課題の成績を登録
INSERT INTO grades (student_id, course_id, grade_type, score, max_score, submission_date)
SELECT 
    sc.student_id,
    '31',
    'レポート1',
    ROUND(60 + (RAND() * 40), 1),  -- 60-100点のランダムな点数
    100,
    '2025-06-20'
FROM student_courses sc
WHERE sc.course_id = '31'
AND RAND() > 0.1;  -- 90%の学生が提出（10%は未提出）
```

## INSERT文のパフォーマンス考慮点

### 1. 一括挿入の活用

```sql
-- 効率的：一括挿入
INSERT INTO students (student_id, student_name)
VALUES 
    (332, '学生A'),
    (333, '学生B'),
    (334, '学生C');

-- 非効率的：個別挿入
INSERT INTO students (student_id, student_name) VALUES (332, '学生A');
INSERT INTO students (student_id, student_name) VALUES (333, '学生B');
INSERT INTO students (student_id, student_name) VALUES (334, '学生C');
```

### 2. トランザクションの使用

大量データの挿入時にはトランザクションを使用：

```sql
START TRANSACTION;

INSERT INTO students (student_id, student_name)
VALUES (335, '学生D'), (336, '学生E');

INSERT INTO student_courses (course_id, student_id)
VALUES ('1', 335), ('2', 335), ('1', 336), ('2', 336);

COMMIT;
```

### 3. インデックスへの配慮

大量データ挿入時は、一時的にインデックスを無効化することでパフォーマンスが向上する場合があります（ただし、注意が必要）。

## INSERT文のエラーと対処法

### よくあるエラーとその対処法

1. **主キー重複エラー**
```sql
-- エラー例
INSERT INTO students (student_id, student_name) VALUES (301, '重複学生');
-- エラー: Duplicate entry '301' for key 'PRIMARY'

-- 対処法1: INSERT IGNORE
INSERT IGNORE INTO students (student_id, student_name) VALUES (301, '重複学生');

-- 対処法2: ON DUPLICATE KEY UPDATE
INSERT INTO students (student_id, student_name) VALUES (301, '更新学生')
ON DUPLICATE KEY UPDATE student_name = '更新学生';
```

2. **外部キー制約エラー**
```sql
-- エラー例（存在しない教師IDを指定）
INSERT INTO courses (course_id, course_name, teacher_id) 
VALUES ('32', 'テスト講座', 999);
-- エラー: Cannot add or update a child row: a foreign key constraint fails

-- 対処法：事前に参照先の存在確認
INSERT INTO courses (course_id, course_name, teacher_id)
SELECT '32', 'テスト講座', 109
WHERE EXISTS (SELECT 1 FROM teachers WHERE teacher_id = 109);
```

3. **NULL制約エラー**
```sql
-- エラー例（NOT NULLカラムにNULLを挿入）
INSERT INTO courses (course_id, teacher_id) VALUES ('33', 101);
-- エラー: Field 'course_name' doesn't have a default value

-- 対処法：必須カラムに値を指定
INSERT INTO courses (course_id, course_name, teacher_id) 
VALUES ('33', '講座名を指定', 101);
```

## INSERT文のベストプラクティス

### 1. カラム名の明示

```sql
-- 推奨：カラム名を明示
INSERT INTO students (student_id, student_name)
VALUES (337, '新学生');

-- 非推奨：カラム名の省略（メンテナンス性が低い）
INSERT INTO students VALUES (337, '新学生');
```

### 2. データ型の適切な指定

```sql
-- 適切なデータ型での挿入
INSERT INTO grades (student_id, course_id, grade_type, score, max_score)
VALUES (301, '1', '期末テスト', 85.5, 100.0);
```

### 3. 日付データの適切な指定

```sql
-- 推奨：標準的な日付形式
INSERT INTO course_schedule (course_id, schedule_date, period_id, classroom_id, teacher_id)
VALUES ('1', '2025-06-30', 1, '101A', 101);

-- 現在日時の使用
INSERT INTO grades (student_id, course_id, grade_type, score, max_score, submission_date)
VALUES (301, '1', '追加課題', 90.0, 100.0, CURRENT_DATE);
```

## 練習問題

### 問題26-1
新しい教師「田中英子」（teacher_id = 110）を登録するINSERT文を書いてください。

### 問題26-2
以下の3人の学生を一括で登録するINSERT文を書いてください：
- 学生ID: 338, 名前: 中村太郎
- 学生ID: 339, 名前: 佐々木花音
- 学生ID: 340, 名前: 高田次郎

### 問題26-3
新しい講座「Python基礎」（course_id = '32'）を田中英子先生（teacher_id = 110）の担当で登録し、学生ID 301-305の学生をこの講座に受講登録するINSERT文を書いてください（2つのINSERT文で実現）。

### 問題26-4
INSERT SELECTを使用して、平均出席率が80%以上の学生を「high_attendance_students」テーブルに登録するINSERT文を書いてください。テーブル構造は以下の通りです：
```sql
CREATE TABLE high_attendance_students (
    student_id BIGINT,
    student_name VARCHAR(64),
    attendance_rate DECIMAL(5,2)
);
```

### 問題26-5
2025年6月の毎週月曜日（6/2, 6/9, 6/16, 6/23, 6/30）に「Python基礎」講座の授業スケジュールを登録するINSERT文を書いてください。時限は2限、教室は「501A」、担当教師は田中英子先生とします。

### 問題26-6
ON DUPLICATE KEY UPDATEを使用して、学生ID=301の学生名を「黒沢春馬（更新）」に更新するか、存在しない場合は新規登録するINSERT文を書いてください。

## 解答

### 解答26-1
```sql
INSERT INTO teachers (teacher_id, teacher_name)
VALUES (110, '田中英子');
```

### 解答26-2
```sql
INSERT INTO students (student_id, student_name)
VALUES 
    (338, '中村太郎'),
    (339, '佐々木花音'),
    (340, '高田次郎');
```

### 解答26-3
```sql
-- 新しい講座の登録
INSERT INTO courses (course_id, course_name, teacher_id)
VALUES ('32', 'Python基礎', 110);

-- 学生の受講登録
INSERT INTO student_courses (course_id, student_id)
VALUES 
    ('32', 301),
    ('32', 302),
    ('32', 303),
    ('32', 304),
    ('32', 305);
```

### 解答26-4
```sql
INSERT INTO high_attendance_students (student_id, student_name, attendance_rate)
SELECT 
    s.student_id,
    s.student_name,
    ROUND(AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END), 2) AS attendance_rate
FROM students s
JOIN attendance a ON s.student_id = a.student_id
GROUP BY s.student_id, s.student_name
HAVING AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) >= 80;
```

### 解答26-5
```sql
INSERT INTO course_schedule (course_id, schedule_date, period_id, classroom_id, teacher_id)
VALUES 
    ('32', '2025-06-02', 2, '501A', 110),
    ('32', '2025-06-09', 2, '501A', 110),
    ('32', '2025-06-16', 2, '501A', 110),
    ('32', '2025-06-23', 2, '501A', 110),
    ('32', '2025-06-30', 2, '501A', 110);
```

### 解答26-6
```sql
INSERT INTO students (student_id, student_name)
VALUES (301, '黒沢春馬（更新）')
ON DUPLICATE KEY UPDATE student_name = VALUES(student_name);
```

## まとめ

この章では、INSERT文について詳しく学びました：

1. **INSERT文の基本概念**：
   - テーブルに新しいレコードを追加するSQL文
   - データベースのCRUD操作の「Create」に該当
   - 基本構文とカラム指定の方法

2. **基本的なINSERT文**：
   - 単一行の挿入
   - カラム名の明示指定と省略
   - 値の直接指定

3. **複数行の一括挿入**：
   - 複数のVALUES句による効率的な挿入
   - パフォーマンス向上のメリット

4. **INSERT SELECT文**：
   - 他のテーブルからのデータ挿入
   - 条件付きデータの移行
   - 集計結果の挿入

5. **NULL値とデフォルト値**：
   - NULL値の明示的指定
   - DEFAULTキーワードの使用
   - カラム省略によるデフォルト値の適用

6. **条件付きINSERT**：
   - INSERT IGNOREによる重複エラーの無視
   - ON DUPLICATE KEY UPDATEによる更新処理

7. **実践的な活用例**：
   - 新学期スケジュールの一括登録
   - 出席データと成績データの挿入
   - 段階的なデータ構築

8. **パフォーマンスとエラー対処**：
   - 効率的な挿入方法
   - よくあるエラーと対処法
   - ベストプラクティス

INSERT文は、データベースにデータを蓄積するための基本的で重要な操作です。適切に使用することで、効率的にデータを構築し、システムの基盤を作ることができます。

次の章では、「データ更新：UPDATE文」について学び、既存データの変更方法を理解していきます。

------------------------------------------------------------

# 27. データ更新：UPDATE文

## はじめに

前章では、INSERT文を使用してデータベースに新しいデータを挿入する方法を学びました。この章では、既存のデータを変更・更新するための「UPDATE文」について学習します。

UPDATE文は、テーブル内の既存レコードの値を変更するためのSQL文で、データベースの基本操作CRUD（Create、Read、Update、Delete）の「Update」に該当します。

UPDATE文が必要となる場面の例：
- 「学生の名前に変更があったので更新したい」
- 「講座の担当教師を変更したい」
- 「成績の入力ミスを修正したい」
- 「授業のステータスを『予定』から『完了』に変更したい」
- 「一括で出席ポイントを加算したい」
- 「データクリーニングで不正な値を修正したい」

UPDATE文は非常に強力な機能ですが、誤った使用により大量のデータが意図せず変更される危険性もあります。安全な使用方法も含めて詳しく学んでいきます。

## UPDATE文とは

UPDATE文は、テーブル内の既存レコードの一部または全部のカラム値を変更するためのSQL文です。WHERE句と組み合わせることで、特定の条件に一致するレコードのみを更新できます。

> **用語解説**：
> - **UPDATE文**：既存のレコードの値を変更するSQL文です。
> - **SET句**：更新するカラム名と新しい値を指定する部分です。
> - **WHERE句**：更新対象のレコードを限定するための条件を指定します。
> - **一括更新**：複数のレコードを一度のUPDATE文で更新することです。
> - **条件付き更新**：CASE式などを使用して、条件に応じて異なる値で更新することです。
> - **結合更新**：JOINを使用して他のテーブルの情報を参照しながら更新することです。

## UPDATE文の基本構文

```sql
UPDATE テーブル名
SET カラム1 = 値1, カラム2 = 値2, ...
WHERE 条件;
```

### 重要な注意事項

**WHERE句を省略すると、テーブル内のすべてのレコードが更新されます。**これは意図しない大量更新を引き起こす可能性があるため、特に注意が必要です。

## 基本的なUPDATE文の例

### 例1：単一レコードの単一カラム更新

学生ID=301の学生名を変更：

```sql
-- 更新前の確認
SELECT student_id, student_name FROM students WHERE student_id = 301;

-- 更新実行
UPDATE students
SET student_name = '黒沢春馬（更新済み）'
WHERE student_id = 301;

-- 更新後の確認
SELECT student_id, student_name FROM students WHERE student_id = 301;
```

### 例2：複数カラムの同時更新

教室の情報を複数のカラムで同時に更新：

```sql
-- 更新前の確認
SELECT * FROM classrooms WHERE classroom_id = '101A';

-- 複数カラムの同時更新
UPDATE classrooms
SET 
    capacity = 45,
    facilities = 'PC30台、プロジェクター、ホワイトボード、エアコン'
WHERE classroom_id = '101A';

-- 更新後の確認
SELECT * FROM classrooms WHERE classroom_id = '101A';
```

### 例3：計算による更新

すべての成績に5点のボーナスポイントを加算：

```sql
-- 更新前の確認（一部のデータ）
SELECT student_id, course_id, grade_type, score 
FROM grades 
WHERE grade_type = 'レポート1' 
LIMIT 5;

-- 計算による更新
UPDATE grades
SET score = score + 5
WHERE grade_type = 'レポート1' AND score <= 95;  -- 100点を超えないように制限

-- 更新後の確認
SELECT student_id, course_id, grade_type, score 
FROM grades 
WHERE grade_type = 'レポート1' 
LIMIT 5;
```

## 条件付きUPDATE

WHERE句を使用して、特定の条件に一致するレコードのみを更新できます。

### 例4：複数条件での更新

特定の講座の特定の評価タイプの成績を更新：

```sql
-- ITのための基礎知識の中間テストで80点未満の成績を底上げ
UPDATE grades
SET score = score + 10
WHERE course_id = '1' 
  AND grade_type = '中間テスト' 
  AND score < 80;
```

### 例5：日付条件での更新

特定の日付以降の授業ステータスを更新：

```sql
-- 過去の授業を「完了」ステータスに変更
UPDATE course_schedule
SET status = 'completed'
WHERE schedule_date < CURRENT_DATE 
  AND status = 'scheduled';
```

### 例6：範囲条件での更新

学生IDの範囲を指定した更新：

```sql
-- 学生ID 301-310の学生に特別なマークを追加
UPDATE students
SET student_name = CONCAT(student_name, ' ★')
WHERE student_id BETWEEN 301 AND 310
  AND student_name NOT LIKE '%★%';  -- 既にマークがついていない場合のみ
```

## CASE式を使った条件分岐更新

CASE式を使用することで、条件に応じて異なる値で更新できます。

### 例7：成績に基づく等級の設定

成績テーブルに新しく等級カラムを追加して、点数に基づく等級を設定：

```sql
-- まず等級カラムを追加（実際の運用では必要）
-- ALTER TABLE grades ADD COLUMN grade_letter VARCHAR(2);

-- 点数に基づく等級の設定
UPDATE grades
SET grade_letter = CASE
    WHEN score >= 90 THEN 'A'
    WHEN score >= 80 THEN 'B'
    WHEN score >= 70 THEN 'C'
    WHEN score >= 60 THEN 'D'
    ELSE 'F'
END
WHERE grade_letter IS NULL OR grade_letter = '';
```

### 例8：出席状況に基づく総合評価

出席率に基づいて学生の総合評価を更新：

```sql
-- 学生テーブルに評価カラムを追加（実際の運用では必要）
-- ALTER TABLE students ADD COLUMN overall_rating VARCHAR(20);

-- 出席率に基づく総合評価の設定
UPDATE students s
SET overall_rating = CASE
    WHEN (
        SELECT AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END)
        FROM attendance a
        WHERE a.student_id = s.student_id
    ) >= 90 THEN '優秀'
    WHEN (
        SELECT AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END)
        FROM attendance a
        WHERE a.student_id = s.student_id
    ) >= 80 THEN '良好'
    WHEN (
        SELECT AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END)
        FROM attendance a
        WHERE a.student_id = s.student_id
    ) >= 70 THEN '普通'
    ELSE '要改善'
END;
```

## JOINを使ったUPDATE

他のテーブルの情報を参照しながら更新を行う場合に使用します。

### 例9：教師名に基づく講座情報の更新

教師テーブルの情報を参照して講座の説明を更新：

```sql
-- 講座テーブルに説明カラムを追加（実際の運用では必要）
-- ALTER TABLE courses ADD COLUMN description TEXT;

-- JOINを使用した更新
UPDATE courses c
JOIN teachers t ON c.teacher_id = t.teacher_id
SET c.description = CONCAT('担当教師：', t.teacher_name, 'が指導する', c.course_name, 'の講座です。')
WHERE c.description IS NULL;
```

### 例10：平均点に基づく講座の難易度設定

各講座の平均点を基に難易度を設定：

```sql
-- 講座テーブルに難易度カラムを追加（実際の運用では必要）
-- ALTER TABLE courses ADD COLUMN difficulty_level VARCHAR(20);

-- 平均点に基づく難易度の設定
UPDATE courses c
JOIN (
    SELECT 
        course_id,
        AVG(score) as avg_score
    FROM grades
    GROUP BY course_id
) g ON c.course_id = g.course_id
SET c.difficulty_level = CASE
    WHEN g.avg_score >= 85 THEN '易しい'
    WHEN g.avg_score >= 75 THEN '標準'
    WHEN g.avg_score >= 65 THEN '難しい'
    ELSE '非常に難しい'
END;
```

## サブクエリを使ったUPDATE

### 例11：相対的な値での更新

各学生の平均点を基準とした相対評価を追加：

```sql
-- 成績テーブルに相対評価カラムを追加（実際の運用では必要）
-- ALTER TABLE grades ADD COLUMN relative_performance VARCHAR(20);

-- 学生の平均点と比較した相対評価
UPDATE grades g1
SET relative_performance = CASE
    WHEN g1.score > (
        SELECT AVG(g2.score)
        FROM grades g2
        WHERE g2.student_id = g1.student_id
    ) THEN '平均以上'
    WHEN g1.score = (
        SELECT AVG(g2.score)
        FROM grades g2
        WHERE g2.student_id = g1.student_id
    ) THEN '平均'
    ELSE '平均以下'
END;
```

### 例12：講座内順位に基づく更新

講座内での順位に基づいて特別マークを付与：

```sql
-- 成績テーブルに順位マークカラムを追加（実際の運用では必要）
-- ALTER TABLE grades ADD COLUMN rank_marker VARCHAR(10);

-- 講座内上位3位にマークを付与
UPDATE grades g1
SET rank_marker = '上位'
WHERE (
    SELECT COUNT(*)
    FROM grades g2
    WHERE g2.course_id = g1.course_id
      AND g2.grade_type = g1.grade_type
      AND g2.score > g1.score
) < 3
AND g1.grade_type = '中間テスト';
```

## NULL値の処理

### 例13：NULL値の置換

NULL値を適切なデフォルト値に置換：

```sql
-- NULLの成績を0に設定
UPDATE grades
SET score = 0
WHERE score IS NULL;

-- 空文字の評価タイプを「その他」に設定
UPDATE grades
SET grade_type = 'その他'
WHERE grade_type IS NULL OR grade_type = '';
```

### 例14：条件付きNULL設定

特定の条件下でNULLを設定：

```sql
-- 無効な成績データ（負の値や100超）をNULLに設定
UPDATE grades
SET score = NULL
WHERE score < 0 OR score > 100;
```

## 安全なUPDATE操作

### 1. 更新前の確認

```sql
-- 1. 更新対象レコードの確認
SELECT student_id, student_name 
FROM students 
WHERE student_id = 301;

-- 2. 更新実行
UPDATE students 
SET student_name = '新しい名前' 
WHERE student_id = 301;

-- 3. 更新後の確認
SELECT student_id, student_name 
FROM students 
WHERE student_id = 301;
```

### 2. 影響範囲の事前確認

```sql
-- 更新対象の件数を事前確認
SELECT COUNT(*) as update_count
FROM grades
WHERE course_id = '1' AND grade_type = '中間テスト' AND score < 70;

-- 確認後に更新実行
UPDATE grades
SET score = score + 5
WHERE course_id = '1' AND grade_type = '中間テスト' AND score < 70;
```

### 3. LIMIT句の使用（MySQLのみ）

```sql
-- 一度に更新する件数を制限
UPDATE students
SET student_name = CONCAT(student_name, ' (更新)')
WHERE student_id > 300
LIMIT 5;
```

## UPDATE文のパフォーマンス考慮点

### 1. インデックスの活用

```sql
-- WHERE句で使用するカラムにインデックスがあることを確認
-- CREATE INDEX idx_student_id ON grades(student_id);

-- インデックスを活用した効率的な更新
UPDATE grades
SET score = score + 2
WHERE student_id = 301;  -- student_idにインデックスがある場合高速
```

### 2. 大量更新時の分割実行

```sql
-- 大量データの分割更新例
UPDATE grades
SET score = LEAST(score + 3, 100)  -- 100点を超えないように制限
WHERE grade_type = 'レポート1'
  AND student_id BETWEEN 301 AND 310;  -- 範囲を限定

-- 次のバッチ
UPDATE grades
SET score = LEAST(score + 3, 100)
WHERE grade_type = 'レポート1'
  AND student_id BETWEEN 311 AND 320;
```

### 3. 効率的な結合更新

```sql
-- 効率的なJOIN UPDATE
UPDATE courses c
INNER JOIN (
    SELECT course_id, COUNT(*) as student_count
    FROM student_courses
    GROUP BY course_id
) sc ON c.course_id = sc.course_id
SET c.enrollment_count = sc.student_count;
```

## よくあるエラーと対処法

### 1. WHERE句の忘れ

```sql
-- 危険：WHERE句なし（全レコードが更新される）
-- UPDATE students SET student_name = 'テスト';

-- 安全：WHERE句あり
UPDATE students 
SET student_name = 'テスト' 
WHERE student_id = 999;  -- 存在しないIDなので実際は更新されない
```

### 2. 外部キー制約エラー

```sql
-- エラー例：存在しない教師IDに更新しようとする
-- UPDATE courses SET teacher_id = 999 WHERE course_id = '1';

-- 対処法：事前に存在確認
UPDATE courses 
SET teacher_id = 109 
WHERE course_id = '1'
  AND EXISTS (SELECT 1 FROM teachers WHERE teacher_id = 109);
```

### 3. データ型エラー

```sql
-- エラー例：文字列を数値カラムに設定
-- UPDATE grades SET score = '無効な値' WHERE grade_id = 1;

-- 対処法：適切なデータ型で更新
UPDATE grades 
SET score = 85.5 
WHERE student_id = 301 AND course_id = '1';
```

## UPDATE文のベストプラクティス

### 1. トランザクションの使用

```sql
START TRANSACTION;

-- 複数の関連する更新を実行
UPDATE students SET student_name = '更新名前' WHERE student_id = 301;
UPDATE grades SET score = score + 5 WHERE student_id = 301;

-- 問題がなければコミット
COMMIT;

-- 問題があればロールバック
-- ROLLBACK;
```

### 2. バックアップの作成

```sql
-- 重要な更新前にバックアップテーブルを作成
CREATE TABLE grades_backup AS SELECT * FROM grades;

-- 更新実行
UPDATE grades SET score = score * 1.05 WHERE grade_type = '最終評価';

-- 必要に応じて復元
-- DELETE FROM grades;
-- INSERT INTO grades SELECT * FROM grades_backup;
```

### 3. 段階的な更新

```sql
-- ステップ1：少数のレコードでテスト
UPDATE students 
SET student_name = UPPER(student_name) 
WHERE student_id = 301;

-- ステップ2：結果確認後、範囲を拡大
UPDATE students 
SET student_name = UPPER(student_name) 
WHERE student_id BETWEEN 301 AND 305;
```

## 練習問題

### 問題27-1
学生ID=302の学生名を「新垣愛留（修正版）」に更新するUPDATE文を書いてください。

### 問題27-2
「ITのための基礎知識」講座（course_id='1'）の中間テストで70点未満の成績をすべて70点に更新するUPDATE文を書いてください。

### 問題27-3
CASE式を使用して、出席テーブルの'late'（遅刻）を'present'（出席）に、'absent'（欠席）はそのまま、'present'も変更しないUPDATE文を書いてください。

### 問題27-4
JOINを使用して、各講座の受講者数を基に、20人以上の講座の名前に「【人気】」、10人未満の講座の名前に「【少人数】」の接頭辞を追加するUPDATE文を書いてください。

### 問題27-5
サブクエリを使用して、各学生の平均点が85点以上の場合に「優秀学生」、75点以上85点未満の場合に「良好学生」、それ未満の場合に「一般学生」というコメントを学生名の後に追加するUPDATE文を書いてください。

### 問題27-6
2025年5月20日より前の授業スケジュールのステータスを'completed'に、それ以降で現在日より前の授業を'ongoing'に、将来の授業は'scheduled'のままにするUPDATE文を書いてください。

## 解答

### 解答27-1
```sql
UPDATE students
SET student_name = '新垣愛留（修正版）'
WHERE student_id = 302;
```

### 解答27-2
```sql
UPDATE grades
SET score = 70
WHERE course_id = '1' 
  AND grade_type = '中間テスト' 
  AND score < 70;
```

### 解答27-3
```sql
UPDATE attendance
SET status = CASE
    WHEN status = 'late' THEN 'present'
    ELSE status
END
WHERE status = 'late';
```

### 解答27-4
```sql
UPDATE courses c
JOIN (
    SELECT 
        course_id,
        COUNT(student_id) as enrollment_count
    FROM student_courses
    GROUP BY course_id
) sc ON c.course_id = sc.course_id
SET c.course_name = CASE
    WHEN sc.enrollment_count >= 20 THEN CONCAT('【人気】', c.course_name)
    WHEN sc.enrollment_count < 10 THEN CONCAT('【少人数】', c.course_name)
    ELSE c.course_name
END
WHERE c.course_name NOT LIKE '【%】%';  -- 既に接頭辞がついていない場合のみ
```

### 解答27-5
```sql
UPDATE students s
SET student_name = CONCAT(
    s.student_name,
    CASE
        WHEN (
            SELECT AVG(score)
            FROM grades g
            WHERE g.student_id = s.student_id
        ) >= 85 THEN '（優秀学生）'
        WHEN (
            SELECT AVG(score)
            FROM grades g
            WHERE g.student_id = s.student_id
        ) >= 75 THEN '（良好学生）'
        ELSE '（一般学生）'
    END
)
WHERE EXISTS (
    SELECT 1 FROM grades g WHERE g.student_id = s.student_id
)
AND s.student_name NOT LIKE '%（%学生）';  -- 既にコメントがない場合のみ
```

### 解答27-6
```sql
UPDATE course_schedule
SET status = CASE
    WHEN schedule_date < '2025-05-20' THEN 'completed'
    WHEN schedule_date < CURRENT_DATE THEN 'ongoing'
    ELSE 'scheduled'
END
WHERE status != 'cancelled';  -- キャンセルされた授業は除外
```

## まとめ

この章では、UPDATE文について詳しく学びました：

1. **UPDATE文の基本概念**：
   - 既存レコードの値を変更するSQL文
   - SET句による値の指定
   - WHERE句による更新対象の限定

2. **基本的なUPDATE操作**：
   - 単一カラムの更新
   - 複数カラムの同時更新
   - 計算による値の更新

3. **条件付きUPDATE**：
   - WHERE句による条件指定
   - 複数条件の組み合わせ
   - 日付や範囲条件での更新

4. **CASE式を使った条件分岐更新**：
   - 条件に応じた異なる値での更新
   - 複雑な条件分岐の実現

5. **JOINを使ったUPDATE**：
   - 他のテーブルの情報を参照した更新
   - 関連データに基づく値の設定

6. **サブクエリを使ったUPDATE**：
   - 動的な条件での更新
   - 集計結果に基づく更新

7. **安全なUPDATE操作**：
   - 更新前後の確認方法
   - 影響範囲の事前チェック
   - LIMIT句による制限

8. **パフォーマンスとエラー対処**：
   - インデックスの活用
   - 大量更新時の分割実行
   - よくあるエラーの回避

9. **ベストプラクティス**：
   - トランザクションの使用
   - バックアップの作成
   - 段階的な更新アプローチ

UPDATE文は強力な機能ですが、WHERE句の忘れなどにより意図しない大量更新が発生する危険性があります。常に安全性を意識し、適切な手順で実行することが重要です。

次の章では、「データ削除：DELETE文」について学び、不要なデータを安全に削除する方法を理解していきます。

------------------------------------------------------------

# 28. データ削除：DELETE文

## はじめに

前章では、UPDATE文を使用してデータを更新する方法を学びました。この章では、不要になったデータをデータベースから削除するための「DELETE文」について学習します。

DELETE文は、テーブルからレコード（行）を削除するためのSQL文で、データベースの基本操作CRUD（Create、Read、Update、Delete）の「Delete」に該当します。

DELETE文が必要となる場面の例：
- 「退学した学生のデータを削除したい」
- 「キャンセルされた授業の記録を削除したい」
- 「古いテストデータを削除したい」
- 「重複したデータを削除したい」
- 「一定期間経過した出席記録をアーカイブしたい」
- 「システム移行前の不要データを削除したい」

DELETE文は非常に強力で便利な機能ですが、**一度削除されたデータは元に戻すことができません**。UPDATE文以上に慎重な操作が必要です。安全な使用方法と注意点を含めて詳しく学んでいきます。

## DELETE文とは

DELETE文は、テーブルから指定した条件に一致するレコードを完全に削除するためのSQL文です。削除されたデータは、特別な復旧手段がない限り永続的に失われます。

> **用語解説**：
> - **DELETE文**：テーブルからレコード（行）を削除するSQL文です。
> - **WHERE句**：削除対象のレコードを限定するための条件を指定します。DELETE文では特に重要です。
> - **TRUNCATE文**：テーブルの全レコードを高速で削除する文です。
> - **CASCADE DELETE**：外部キー制約で関連するレコードも連鎖的に削除する機能です。
> - **論理削除**：実際にレコードを削除せず、削除フラグを設定してデータを無効にする方法です。
> - **物理削除**：DELETE文による実際のレコードの削除です。

## DELETE文の基本構文

```sql
DELETE FROM テーブル名
WHERE 条件;
```

### ⚠️ 極めて重要な注意事項

**WHERE句を省略すると、テーブル内のすべてのレコードが削除されます。**これは取り返しのつかない結果を招く可能性があるため、DELETE文を実行する前は必ずWHERE句の存在と条件を確認してください。

## 基本的なDELETE文の例

### 例1：単一レコードの削除

特定の学生を削除（注意：実際の運用では外部キー制約により削除できない場合があります）：

```sql
-- 削除前の確認
SELECT student_id, student_name FROM students WHERE student_id = 340;

-- 削除実行
DELETE FROM students
WHERE student_id = 340;

-- 削除後の確認
SELECT student_id, student_name FROM students WHERE student_id = 340;
-- 結果：0行が返される（削除されたため）
```

### 例2：複数の条件での削除

特定の講座の特定タイプの成績を削除：

```sql
-- 削除前の確認
SELECT COUNT(*) as delete_count
FROM grades
WHERE course_id = '32' AND grade_type = 'テスト課題';

-- 削除実行
DELETE FROM grades
WHERE course_id = '32' AND grade_type = 'テスト課題';
```

### 例3：日付条件での削除

古い出席記録を削除：

```sql
-- 2025年4月以前の出席記録を削除
-- 削除前の確認
SELECT COUNT(*) as old_records
FROM attendance a
JOIN course_schedule cs ON a.schedule_id = cs.schedule_id
WHERE cs.schedule_date < '2025-05-01';

-- 削除実行
DELETE a FROM attendance a
JOIN course_schedule cs ON a.schedule_id = cs.schedule_id
WHERE cs.schedule_date < '2025-05-01';
```

## 条件付きDELETE

WHERE句を使用して、特定の条件に一致するレコードのみを削除できます。

### 例4：範囲条件での削除

テスト用に作成した学生データを削除：

```sql
-- 学生ID 330番台のテストデータを削除
-- 削除前の確認
SELECT student_id, student_name 
FROM students 
WHERE student_id BETWEEN 330 AND 339;

-- 外部キー制約を確認し、関連データがある場合は先に削除
DELETE FROM student_courses WHERE student_id BETWEEN 330 AND 339;
DELETE FROM attendance WHERE student_id BETWEEN 330 AND 339;
DELETE FROM grades WHERE student_id BETWEEN 330 AND 339;

-- 最後に学生データを削除
DELETE FROM students
WHERE student_id BETWEEN 330 AND 339;
```

### 例5：NULL値を条件とした削除

不完全なデータを削除：

```sql
-- 成績が記録されていない（NULL）レコードを削除
DELETE FROM grades
WHERE score IS NULL AND submission_date IS NULL;
```

### 例6：LIKE演算子での削除

特定のパターンに一致するデータを削除：

```sql
-- テスト用の講座（名前に「テスト」が含まれる）を削除
-- まず関連データを削除
DELETE FROM student_courses 
WHERE course_id IN (
    SELECT course_id FROM courses WHERE course_name LIKE '%テスト%'
);

DELETE FROM course_schedule 
WHERE course_id IN (
    SELECT course_id FROM courses WHERE course_name LIKE '%テスト%'
);

DELETE FROM grades 
WHERE course_id IN (
    SELECT course_id FROM courses WHERE course_name LIKE '%テスト%'
);

-- 最後に講座データを削除
DELETE FROM courses
WHERE course_name LIKE '%テスト%';
```

## JOINを使ったDELETE

他のテーブルの情報を参照しながら削除を行う場合に使用します。

### 例7：関連データに基づく削除

担当教師が不在の期間中の授業記録を削除：

```sql
-- 教師の不在期間と重なる授業スケジュールを削除
DELETE cs FROM course_schedule cs
JOIN teacher_unavailability tu ON cs.teacher_id = tu.teacher_id
WHERE cs.schedule_date BETWEEN tu.start_date AND tu.end_date
  AND cs.status = 'cancelled';
```

### 例8：集計結果に基づく削除

受講者が1人もいない講座を削除：

```sql
-- 受講者のいない講座を特定
SELECT c.course_id, c.course_name
FROM courses c
LEFT JOIN student_courses sc ON c.course_id = sc.course_id
WHERE sc.course_id IS NULL;

-- 関連データを削除（授業スケジュール）
DELETE cs FROM course_schedule cs
LEFT JOIN student_courses sc ON cs.course_id = sc.course_id
WHERE sc.course_id IS NULL;

-- 講座データを削除
DELETE c FROM courses c
LEFT JOIN student_courses sc ON c.course_id = sc.course_id
WHERE sc.course_id IS NULL;
```

## サブクエリを使ったDELETE

### 例9：平均点が低い成績データの削除

全体平均よりも大幅に低い成績（平均-20点以下）を削除：

```sql
-- 削除対象の確認
SELECT student_id, course_id, grade_type, score
FROM grades
WHERE score < (SELECT AVG(score) - 20 FROM grades)
ORDER BY score;

-- 削除実行
DELETE FROM grades
WHERE score < (SELECT AVG(score) - 20 FROM grades);
```

### 例10：重複データの削除

同じ学生が同じ講座を重複受講している場合の削除：

```sql
-- 重複レコードの特定
SELECT student_id, course_id, COUNT(*) as duplicate_count
FROM student_courses
GROUP BY student_id, course_id
HAVING COUNT(*) > 1;

-- 重複レコードの削除（最小のIDを残して他を削除）
DELETE sc1 FROM student_courses sc1
JOIN student_courses sc2 ON sc1.student_id = sc2.student_id 
                         AND sc1.course_id = sc2.course_id
WHERE sc1.course_id > sc2.course_id;  -- より大きなIDのレコードを削除
```

## LIMIT句を使った削除

MySQLでは、DELETE文でLIMIT句を使用して削除件数を制限できます。

### 例11：件数を制限した削除

```sql
-- 古い出席記録を少しずつ削除
DELETE FROM attendance 
WHERE schedule_id IN (
    SELECT schedule_id FROM course_schedule 
    WHERE schedule_date < '2025-04-01'
)
LIMIT 100;  -- 一度に100件まで削除
```

## 外部キー制約とDELETE

外部キー制約がある場合、参照されているレコードは削除できません。

### 例12：外部キー制約を考慮した削除

```sql
-- 学生を削除する場合の正しい手順

-- 1. 削除対象の学生の関連データを確認
SELECT '成績' as table_name, COUNT(*) as count FROM grades WHERE student_id = 325
UNION ALL
SELECT '出席', COUNT(*) FROM attendance WHERE student_id = 325
UNION ALL
SELECT '受講', COUNT(*) FROM student_courses WHERE student_id = 325;

-- 2. 関連データを順序良く削除
DELETE FROM grades WHERE student_id = 325;
DELETE FROM attendance WHERE student_id = 325;
DELETE FROM student_courses WHERE student_id = 325;

-- 3. 最後に学生データを削除
DELETE FROM students WHERE student_id = 325;
```

### CASCADE DELETEの活用

外部キー制約にCASCADE オプションが設定されている場合、親レコードの削除時に子レコードも自動削除されます：

```sql
-- CASCADE DELETEが設定されている場合
-- （外部キー制約の設定例）
-- ALTER TABLE grades 
-- ADD CONSTRAINT fk_grades_student 
-- FOREIGN KEY (student_id) REFERENCES students(student_id) 
-- ON DELETE CASCADE;

-- 学生を削除すると、関連する成績データも自動削除される
DELETE FROM students WHERE student_id = 325;
```

## TRUNCATE文との違い

TRUNCATE文は、テーブルの全レコードを高速で削除する文です。

### TRUNCATE文の例

```sql
-- テーブルの全データを削除（高速）
TRUNCATE TABLE test_grades;
```

### DELETE文とTRUNCATE文の比較

| 項目 | DELETE | TRUNCATE |
|------|--------|----------|
| **実行速度** | 遅い（レコード単位） | 高速（テーブル単位） |
| **WHERE句** | 使用可能 | 使用不可 |
| **ロールバック** | 可能 | 不可（一部のDB） |
| **外部キー制約** | チェックされる | 制約があると実行不可 |
| **トリガー** | 実行される | 実行されない |
| **AUTO_INCREMENT** | リセットされない | リセットされる |

## 論理削除 vs 物理削除

### 論理削除の実装例

```sql
-- 学生テーブルに削除フラグを追加（実際の運用では必要）
-- ALTER TABLE students ADD COLUMN is_deleted BOOLEAN DEFAULT FALSE;

-- 論理削除の実行
UPDATE students 
SET is_deleted = TRUE 
WHERE student_id = 325;

-- 論理削除されていない学生のみを取得
SELECT student_id, student_name 
FROM students 
WHERE is_deleted = FALSE OR is_deleted IS NULL;
```

### 物理削除と論理削除の使い分け

| シナリオ | 推奨方法 | 理由 |
|----------|----------|------|
| **学生の退学** | 論理削除 | 履歴として保持が必要 |
| **テストデータ** | 物理削除 | 不要なデータの完全除去 |
| **個人情報** | 物理削除 | プライバシー保護 |
| **一時的な無効化** | 論理削除 | 復元の可能性 |

## 安全なDELETE操作

### 1. 削除前の必須チェック

```sql
-- Step 1: 削除対象レコードの確認
SELECT student_id, student_name 
FROM students 
WHERE student_id = 325;

-- Step 2: 関連データの確認
SELECT COUNT(*) as related_grades FROM grades WHERE student_id = 325;
SELECT COUNT(*) as related_attendance FROM attendance WHERE student_id = 325;

-- Step 3: バックアップの作成（重要な場合）
CREATE TABLE students_backup_20250522 AS 
SELECT * FROM students WHERE student_id = 325;

-- Step 4: 削除実行
DELETE FROM students WHERE student_id = 325;

-- Step 5: 削除結果の確認
SELECT student_id, student_name FROM students WHERE student_id = 325;
-- 結果: 0行（削除成功）
```

### 2. トランザクションの使用

```sql
START TRANSACTION;

-- 関連データの削除
DELETE FROM grades WHERE student_id = 325;
DELETE FROM attendance WHERE student_id = 325;
DELETE FROM student_courses WHERE student_id = 325;

-- 学生データの削除
DELETE FROM students WHERE student_id = 325;

-- 確認後にコミット
-- 問題がなければ
COMMIT;

-- 問題があれば
-- ROLLBACK;
```

### 3. 影響範囲の事前確認

```sql
-- 削除対象の件数を事前確認
SELECT COUNT(*) as will_be_deleted
FROM grades
WHERE submission_date < '2025-04-01' AND score IS NULL;

-- 確認後に削除実行
DELETE FROM grades
WHERE submission_date < '2025-04-01' AND score IS NULL;
```

## DELETE文のパフォーマンス考慮点

### 1. インデックスの活用

```sql
-- WHERE句で使用するカラムにインデックスを作成
-- CREATE INDEX idx_submission_date ON grades(submission_date);

-- インデックスを活用した効率的な削除
DELETE FROM grades
WHERE submission_date < '2025-04-01';
```

### 2. 大量削除の分割実行

```sql
-- 大量データの削除を分割して実行
DELETE FROM old_attendance 
WHERE schedule_id IN (
    SELECT schedule_id FROM course_schedule 
    WHERE schedule_date < '2025-01-01'
)
LIMIT 1000;  -- 1000件ずつ削除

-- 削除完了まで繰り返し実行
```

### 3. 外部キー制約の一時無効化（注意が必要）

```sql
-- 大量削除時の外部キー制約の一時無効化
SET FOREIGN_KEY_CHECKS = 0;

-- 削除実行
DELETE FROM students WHERE student_id BETWEEN 300 AND 350;

-- 制約を再有効化
SET FOREIGN_KEY_CHECKS = 1;
```

## よくあるエラーと対処法

### 1. WHERE句の忘れ

```sql
-- 危険：WHERE句なし（全レコードが削除される）
-- DELETE FROM students;

-- 安全：WHERE句あり
DELETE FROM students WHERE student_id = 999;  -- 存在しないIDなので実際は削除されない
```

### 2. 外部キー制約エラー

```sql
-- エラー例：参照されているレコードの削除
-- DELETE FROM students WHERE student_id = 301;
-- エラー: Cannot delete or update a parent row: a foreign key constraint fails

-- 対処法：関連データを先に削除
DELETE FROM grades WHERE student_id = 301;
DELETE FROM attendance WHERE student_id = 301;
DELETE FROM student_courses WHERE student_id = 301;
DELETE FROM students WHERE student_id = 301;
```

## ベストプラクティス

### 1. 段階的な削除

```sql
-- 小規模でテスト
DELETE FROM test_table WHERE id = 1;

-- 結果確認後、範囲を拡大
DELETE FROM test_table WHERE id BETWEEN 1 AND 10;
```

### 2. バックアップの作成

```sql
-- 重要なデータの削除前にバックアップ
CREATE TABLE grades_backup_20250522 AS 
SELECT * FROM grades WHERE course_id = '32';

-- 削除実行
DELETE FROM grades WHERE course_id = '32';

-- 必要に応じて復元
-- INSERT INTO grades SELECT * FROM grades_backup_20250522;
```

### 3. ログ記録

```sql
-- 削除ログテーブルの作成
CREATE TABLE deletion_log (
    log_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(50),
    deleted_count INT,
    deletion_condition TEXT,
    deleted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 削除前にログ記録
INSERT INTO deletion_log (table_name, deleted_count, deletion_condition)
SELECT 'grades', COUNT(*), 'course_id = "32" AND score IS NULL'
FROM grades WHERE course_id = '32' AND score IS NULL;

-- 削除実行
DELETE FROM grades WHERE course_id = '32' AND score IS NULL;
```

## 練習問題

### 問題28-1
学生ID=339の学生を安全に削除するための一連のDELETE文を書いてください。関連データも含めて適切な順序で削除してください。

### 問題28-2
2025年4月以前の出席記録をすべて削除するDELETE文を書いてください。JOINを使用してください。

### 問題28-3
成績が60点未満で、かつ提出日がNULLの成績レコードを削除するDELETE文を書いてください。

### 問題28-4
サブクエリを使用して、受講者が5人未満の講座に関する授業スケジュールをすべて削除するDELETE文を書いてください。

### 問題28-5
JOINとサブクエリを組み合わせて、教師の不在期間と重複している授業のうち、出席者が0人の授業記録（attendance テーブル）を削除するDELETE文を書いてください。

### 問題28-6
重複している成績データ（同じ学生・同じ講座・同じ評価タイプ）のうち、より新しい提出日のレコードを残して古いものを削除するDELETE文を書いてください。

## 解答

### 解答28-1
```sql
-- Step 1: 削除前の確認
SELECT student_id, student_name FROM students WHERE student_id = 339;

-- Step 2: 関連データの削除（外部キー制約順）
DELETE FROM grades WHERE student_id = 339;
DELETE FROM attendance WHERE student_id = 339;
DELETE FROM student_courses WHERE student_id = 339;

-- Step 3: 学生データの削除
DELETE FROM students WHERE student_id = 339;

-- Step 4: 削除確認
SELECT student_id, student_name FROM students WHERE student_id = 339;
```

### 解答28-2
```sql
DELETE a FROM attendance a
JOIN course_schedule cs ON a.schedule_id = cs.schedule_id
WHERE cs.schedule_date < '2025-05-01';
```

### 解答28-3
```sql
DELETE FROM grades
WHERE score < 60 AND submission_date IS NULL;
```

### 解答28-4
```sql
DELETE FROM course_schedule
WHERE course_id IN (
    SELECT course_id
    FROM (
        SELECT c.course_id
        FROM courses c
        LEFT JOIN student_courses sc ON c.course_id = sc.course_id
        GROUP BY c.course_id
        HAVING COUNT(sc.student_id) < 5
    ) AS low_enrollment_courses
);
```

### 解答28-5
```sql
DELETE a FROM attendance a
JOIN course_schedule cs ON a.schedule_id = cs.schedule_id
JOIN teacher_unavailability tu ON cs.teacher_id = tu.teacher_id
WHERE cs.schedule_date BETWEEN tu.start_date AND tu.end_date
AND cs.schedule_id NOT IN (
    SELECT DISTINCT schedule_id
    FROM attendance
    WHERE status = 'present'
);
```

### 解答28-6
```sql
DELETE g1 FROM grades g1
JOIN grades g2 ON g1.student_id = g2.student_id 
               AND g1.course_id = g2.course_id 
               AND g1.grade_type = g2.grade_type
WHERE g1.submission_date < g2.submission_date
   OR (g1.submission_date = g2.submission_date AND g1.grade_id < g2.grade_id);
```

## まとめ

この章では、DELETE文について詳しく学びました：

1. **DELETE文の基本概念**：
   - テーブルからレコードを削除するSQL文
   - 削除されたデータは基本的に復元不可能
   - WHERE句の重要性

2. **基本的なDELETE操作**：
   - 単一レコードの削除
   - 条件付き削除
   - 複数条件での削除

3. **高度なDELETE技術**：
   - JOINを使った削除
   - サブクエリを使った削除
   - LIMIT句による件数制限

4. **外部キー制約への対応**：
   - 関連データの適切な削除順序
   - CASCADE DELETEの活用
   - 制約エラーの回避

5. **TRUNCATE文との違い**：
   - パフォーマンスの違い
   - 機能の違い
   - 使い分けの基準

6. **論理削除 vs 物理削除**：
   - それぞれの特徴と使い分け
   - 履歴保持の重要性

7. **安全なDELETE操作**：
   - 削除前の必須チェック
   - トランザクションの使用
   - バックアップの作成

8. **パフォーマンスとエラー対処**：
   - インデックスの活用
   - 大量削除の分割実行
   - よくあるエラーの回避

9. **ベストプラクティス**：
   - 段階的な削除
   - ログ記録
   - 復元可能性の考慮

DELETE文は、データベース操作の中でも特に慎重に扱う必要がある機能です。適切な手順と安全対策を講じることで、安全かつ効率的にデータ削除を行うことができます。

次の章では、「トランザクション：BEGIN、COMMIT、ROLLBACK」について学び、複数の操作をまとめて安全に実行する方法を理解していきます。

------------------------------------------------------------

# 29. トランザクション：BEGIN、COMMIT、ROLLBACK

## はじめに

これまでの章で、INSERT、UPDATE、DELETE文を学び、データベースの基本的な操作方法を習得しました。しかし、実際のシステムでは、複数の操作を組み合わせて一つの処理を完成させることが多くあります。この章では、複数のSQL文をまとめて安全に実行するための「トランザクション」について学習します。

トランザクションが必要となる場面の例：
- 「学生の転校処理：旧学校からの削除と新学校への登録を同時に実行」
- 「成績の一括更新：中間テストと期末テストの成績を同時に入力」
- 「講座の開設：講座作成、教師の割り当て、教室の予約を一連の処理として実行」
- 「システム障害時の復旧：エラーが発生した場合、変更をすべて取り消し」
- 「データ移行：複数テーブルのデータを整合性を保ちながら移行」

トランザクションは、これらの複雑な処理を安全かつ確実に実行するための仕組みです。「すべて成功するか、すべて失敗するか」のいずれかを保証し、中途半端な状態を防ぎます。

## トランザクションとは

トランザクションとは、データベースに対する一連の操作をひとまとまりとして扱う仕組みです。トランザクション内のすべての操作が成功した場合のみ変更を確定し、一つでも失敗した場合はすべての変更を取り消します。

> **用語解説**：
> - **トランザクション**：データベースに対する一連の操作をひとまとまりとして扱う単位です。
> - **BEGIN/START TRANSACTION**：トランザクションの開始を宣言する文です。
> - **COMMIT**：トランザクション内の変更をデータベースに確定する文です。
> - **ROLLBACK**：トランザクション内の変更をすべて取り消す文です。
> - **オートコミット**：各SQL文が自動的にコミットされるモードです。
> - **ACID特性**：トランザクションが満たすべき4つの特性（原子性、一貫性、独立性、永続性）です。

## ACID特性

トランザクションは、以下の4つの特性（ACID特性）を満たす必要があります：

### 1. Atomicity（原子性）
トランザクション内の操作は「すべて実行されるか、まったく実行されないか」のどちらかです。部分的な実行はありません。

### 2. Consistency（一貫性）
トランザクションの実行により、データベースは一つの整合性のある状態から別の整合性のある状態に移行します。

### 3. Isolation（独立性）
複数のトランザクションが同時に実行されても、それぞれが独立して実行されているように見えます。

### 4. Durability（永続性）
コミットされたトランザクションの結果は、システム障害が発生しても永続的に保持されます。

## トランザクションの基本構文

### 基本的な構文

```sql
-- トランザクションの開始
BEGIN;
-- または
START TRANSACTION;

-- 一連のSQL文
INSERT INTO ...;
UPDATE ...;
DELETE FROM ...;

-- 成功時：変更を確定
COMMIT;

-- 失敗時：変更を取り消し
-- ROLLBACK;
```

## 基本的なトランザクションの例

### 例1：新しい学生の登録処理

新しい学生を登録し、同時に指定された講座に受講登録する処理：

```sql
-- トランザクション開始
START TRANSACTION;

-- 学生の登録
INSERT INTO students (student_id, student_name)
VALUES (341, '新入生太郎');

-- 受講登録
INSERT INTO student_courses (course_id, student_id)
VALUES 
    ('1', 341),   -- ITのための基礎知識
    ('2', 341),   -- UNIX入門
    ('7', 341);   -- AI・機械学習入門

-- 出席記録の初期化（既存の授業分）
INSERT INTO attendance (schedule_id, student_id, status)
SELECT cs.schedule_id, 341, 'absent'  -- 過去の授業は欠席扱い
FROM course_schedule cs
WHERE cs.course_id IN ('1', '2', '7')
  AND cs.schedule_date < CURRENT_DATE;

-- すべて成功した場合、変更を確定
COMMIT;

-- 確認
SELECT s.student_name, c.course_name
FROM students s
JOIN student_courses sc ON s.student_id = sc.student_id
JOIN courses c ON sc.course_id = c.course_id
WHERE s.student_id = 341;
```

### 例2：成績の一括更新処理

複数の評価タイプの成績を同時に更新する処理：

```sql
-- トランザクション開始
BEGIN;

-- 中間テストの成績更新
UPDATE grades 
SET score = score * 1.05  -- 5%のボーナス
WHERE course_id = '1' 
  AND grade_type = '中間テスト' 
  AND score >= 80;

-- レポート評価の成績更新
UPDATE grades 
SET score = LEAST(score + 10, 100)  -- 10点加算（上限100点）
WHERE course_id = '1' 
  AND grade_type = 'レポート1' 
  AND score >= 75;

-- 最終評価の再計算
UPDATE grades 
SET score = (
    SELECT ROUND(AVG(g2.score), 1)
    FROM grades g2
    WHERE g2.student_id = grades.student_id
      AND g2.course_id = grades.course_id
      AND g2.grade_type IN ('中間テスト', 'レポート1')
)
WHERE course_id = '1' 
  AND grade_type = '最終評価';

-- 変更を確定
COMMIT;
```

## エラー処理とROLLBACK

### 例3：エラーが発生した場合の処理

```sql
-- トランザクション開始
START TRANSACTION;

-- 教師の登録
INSERT INTO teachers (teacher_id, teacher_name)
VALUES (111, '新任教師');

-- 講座の作成
INSERT INTO courses (course_id, course_name, teacher_id)
VALUES ('33', '新講座', 111);

-- 授業スケジュールの作成
INSERT INTO course_schedule (course_id, schedule_date, period_id, classroom_id, teacher_id)
VALUES ('33', '2025-06-10', 1, '501A', 111);

-- ここで何らかのエラーが発生したとします
-- 例：存在しない教室IDを指定
-- INSERT INTO course_schedule (course_id, schedule_date, period_id, classroom_id, teacher_id)
-- VALUES ('33', '2025-06-11', 1, '存在しない教室', 111);

-- エラーが発生した場合、すべての変更を取り消し
ROLLBACK;

-- 確認：データが挿入されていないことを確認
SELECT * FROM teachers WHERE teacher_id = 111;
SELECT * FROM courses WHERE course_id = '33';
-- 結果：0行（ROLLBACKにより挿入が取り消された）
```

## 条件付きトランザクション処理

### 例4：条件によるCOMMITとROLLBACK

```sql
DELIMITER //

CREATE PROCEDURE AddStudentWithValidation(
    IN p_student_id BIGINT,
    IN p_student_name VARCHAR(64),
    IN p_course_ids TEXT  -- カンマ区切りの講座ID
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- 学生の重複チェック
    IF EXISTS (SELECT 1 FROM students WHERE student_id = p_student_id) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '学生IDが既に存在します';
    END IF;
    
    -- 学生の登録
    INSERT INTO students (student_id, student_name)
    VALUES (p_student_id, p_student_name);
    
    -- 講座の受講登録（講座IDが有効かチェック）
    INSERT INTO student_courses (course_id, student_id)
    SELECT course_id, p_student_id
    FROM courses
    WHERE FIND_IN_SET(course_id, p_course_ids) > 0;
    
    -- 登録された講座数をチェック
    IF (SELECT COUNT(*) FROM student_courses WHERE student_id = p_student_id) = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '有効な講座が指定されていません';
    END IF;
    
    COMMIT;
END //

DELIMITER ;

-- プロシージャの使用例
CALL AddStudentWithValidation(342, '検証学生', '1,2,3');
```

## 複雑なトランザクションの例

### 例5：講座の統合処理

2つの講座を統合し、片方を削除する複雑な処理：

```sql
START TRANSACTION;

-- 統合前の確認
SELECT 
    '統合前' as timing,
    course_id,
    course_name,
    (SELECT COUNT(*) FROM student_courses sc WHERE sc.course_id = c.course_id) as students
FROM courses c
WHERE course_id IN ('30', '31');

-- 講座31の学生を講座30に移動
UPDATE student_courses 
SET course_id = '30'
WHERE course_id = '31'
  AND student_id NOT IN (
      SELECT student_id FROM student_courses WHERE course_id = '30'
  );

-- 講座31の重複受講者を削除
DELETE FROM student_courses 
WHERE course_id = '31';

-- 講座31の成績を講座30に移動
UPDATE grades 
SET course_id = '30'
WHERE course_id = '31';

-- 講座31の授業スケジュールを講座30に移動
UPDATE course_schedule 
SET course_id = '30'
WHERE course_id = '31';

-- 講座31を削除
DELETE FROM courses WHERE course_id = '31';

-- 統合後の確認
SELECT 
    '統合後' as timing,
    course_id,
    course_name,
    (SELECT COUNT(*) FROM student_courses sc WHERE sc.course_id = c.course_id) as students
FROM courses c
WHERE course_id = '30';

-- 問題がなければコミット
COMMIT;
```

## セーブポイント（SAVEPOINT）

大きなトランザクション内で部分的なロールバックを行うためにセーブポイントを使用できます。

### 例6：セーブポイントの使用

```sql
START TRANSACTION;

-- 基本データの挿入
INSERT INTO students (student_id, student_name) VALUES (343, 'セーブポイント学生');

-- セーブポイント1の設定
SAVEPOINT sp1;

-- 受講登録
INSERT INTO student_courses (course_id, student_id) VALUES ('1', 343);
INSERT INTO student_courses (course_id, student_id) VALUES ('2', 343);

-- セーブポイント2の設定
SAVEPOINT sp2;

-- 成績の初期化（この処理でエラーが発生したとします）
INSERT INTO grades (student_id, course_id, grade_type, score, max_score)
VALUES (343, '1', '中間テスト', 85, 100);

-- エラーが発生した場合、セーブポイント2まで戻る
-- ROLLBACK TO sp2;

-- または、セーブポイント1まで戻る
-- ROLLBACK TO sp1;

-- 最終的なコミット
COMMIT;
```

## トランザクション分離レベル

複数のトランザクションが同時実行される際の動作を制御します。

### 分離レベルの種類

1. **READ UNCOMMITTED**：最も低い分離レベル
2. **READ COMMITTED**：コミットされたデータのみ読取り
3. **REPEATABLE READ**：同一トランザクション内での一貫した読取り（MySQLのデフォルト）
4. **SERIALIZABLE**：最も高い分離レベル

### 例7：分離レベルの設定

```sql
-- セッション単位での分離レベル設定
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- トランザクション単位での分離レベル設定
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

START TRANSACTION;
-- トランザクション処理
COMMIT;
```

## デッドロックの理解と対策

デッドロックは、複数のトランザクションが互いの完了を待って停止状態になることです。

### 例8：デッドロックが発生しやすい状況

```sql
-- セッション1
START TRANSACTION;
UPDATE students SET student_name = '更新1' WHERE student_id = 301;
-- この時点で学生301をロック

-- セッション2
START TRANSACTION;
UPDATE students SET student_name = '更新2' WHERE student_id = 302;
-- この時点で学生302をロック

-- セッション1が学生302を更新しようとする
UPDATE students SET student_name = '更新1-2' WHERE student_id = 302;
-- 待機状態（セッション2が学生302をロック中）

-- セッション2が学生301を更新しようとする
UPDATE students SET student_name = '更新2-1' WHERE student_id = 301;
-- デッドロック発生！
```

### デッドロック対策

```sql
-- 対策1：常に同じ順序でテーブルにアクセス
START TRANSACTION;
-- 常に学生IDの昇順でアクセス
UPDATE students SET student_name = '安全な更新' WHERE student_id = 301;
UPDATE students SET student_name = '安全な更新' WHERE student_id = 302;
COMMIT;

-- 対策2：トランザクションを短時間で完了させる
START TRANSACTION;
UPDATE students SET student_name = '短時間更新' WHERE student_id = 301;
COMMIT;  -- 速やかにコミット
```

## オートコミットモードの制御

### 例9：オートコミットの制御

```sql
-- 現在のオートコミット設定を確認
SELECT @@autocommit;

-- オートコミットを無効化
SET autocommit = 0;

-- 以降のSQL文は明示的にCOMMITするまで確定されない
INSERT INTO students (student_id, student_name) VALUES (344, 'オートコミットテスト');

-- 確認（まだコミットされていない）
SELECT * FROM students WHERE student_id = 344;

-- 明示的にコミット
COMMIT;

-- オートコミットを再有効化
SET autocommit = 1;
```

## トランザクションのベストプラクティス

### 1. トランザクションは短時間で

```sql
-- 良い例：短時間のトランザクション
START TRANSACTION;
UPDATE grades SET score = 85 WHERE student_id = 301 AND course_id = '1';
INSERT INTO grade_history (student_id, course_id, old_score, new_score, changed_at)
VALUES (301, '1', 80, 85, NOW());
COMMIT;

-- 悪い例：長時間のトランザクション
START TRANSACTION;
-- 大量のデータ処理や時間のかかる処理
-- 他のトランザクションをブロックしてしまう
```

### 2. 適切なエラーハンドリング

```sql
START TRANSACTION;

BEGIN
    -- メイン処理
    INSERT INTO students (student_id, student_name) VALUES (345, 'エラーハンドリング学生');
    
    -- 関連処理
    INSERT INTO student_courses (course_id, student_id) VALUES ('1', 345);
    
    COMMIT;
END;

-- エラーが発生した場合の処理
IF @@error_count > 0 THEN
    ROLLBACK;
END IF;
```

### 3. リソースの適切な管理

```sql
-- 接続プールの考慮
START TRANSACTION;

-- 必要最小限の処理のみ
UPDATE students SET student_name = '更新済み' WHERE student_id = 301;

-- 速やかにコミット
COMMIT;

-- 長時間の処理は別途実行
```

## 実践的なトランザクション例

### 例10：学期末処理の自動化

```sql
DELIMITER //

CREATE PROCEDURE EndOfSemesterProcessing()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_student_id BIGINT;
    DECLARE v_course_id VARCHAR(16);
    DECLARE v_final_score DECIMAL(5,2);
    
    DECLARE student_cursor CURSOR FOR
        SELECT DISTINCT student_id, course_id
        FROM grades
        WHERE grade_type IN ('中間テスト', 'レポート1', '課題1');
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- 最終評価の計算と挿入
    OPEN student_cursor;
    
    student_loop: LOOP
        FETCH student_cursor INTO v_student_id, v_course_id;
        IF done THEN
            LEAVE student_loop;
        END IF;
        
        -- 最終スコアの計算
        SELECT AVG(score) INTO v_final_score
        FROM grades
        WHERE student_id = v_student_id 
          AND course_id = v_course_id
          AND grade_type IN ('中間テスト', 'レポート1', '課題1');
        
        -- 最終評価の挿入または更新
        INSERT INTO grades (student_id, course_id, grade_type, score, max_score, submission_date)
        VALUES (v_student_id, v_course_id, '最終評価', v_final_score, 100, CURRENT_DATE)
        ON DUPLICATE KEY UPDATE 
            score = v_final_score,
            submission_date = CURRENT_DATE;
    END LOOP;
    
    CLOSE student_cursor;
    
    -- 学期終了フラグの設定
    UPDATE course_schedule 
    SET status = 'completed'
    WHERE schedule_date <= CURRENT_DATE 
      AND status = 'scheduled';
    
    COMMIT;
END //

DELIMITER ;

-- プロシージャの実行
CALL EndOfSemesterProcessing();
```

## 練習問題

### 問題29-1
新しい教師（teacher_id=112, teacher_name='実習教師'）を登録し、同時にその教師が担当する新しい講座（course_id='34', course_name='実習講座'）を作成するトランザクションを書いてください。

### 問題29-2
学生ID=301の全成績に10%のボーナスを加算し（ただし100点を超えない）、同時に成績変更ログテーブル（grade_change_log）に変更記録を挿入するトランザクションを書いてください。

### 問題29-3
講座ID='32'を削除するために、関連するすべてのデータ（student_courses、grades、course_schedule、courses）を適切な順序で削除するトランザクションを書いてください。エラーが発生した場合はすべてロールバックしてください。

### 問題29-4
セーブポイントを使用して、学生の一括登録処理を書いてください。学生情報の登録後にセーブポイントを設定し、受講登録でエラーが発生した場合は受講登録のみをロールバックして学生情報は保持するトランザクションを作成してください。

### 問題29-5
2つの学生（student_id=301と302）の成績データを入れ替える（301の成績を302に、302の成績を301に移動）トランザクションを書いてください。一時的な学生ID（999）を使用して安全に実行してください。

### 問題29-6
出席率が70%未満の学生に対して警告フラグを設定し、同時に担当教師に通知メッセージを送信するためのデータを挿入する複合トランザクションを書いてください。

## 解答

### 解答29-1
```sql
START TRANSACTION;

-- 教師の登録
INSERT INTO teachers (teacher_id, teacher_name)
VALUES (112, '実習教師');

-- 講座の作成
INSERT INTO courses (course_id, course_name, teacher_id)
VALUES ('34', '実習講座', 112);

-- 成功時にコミット
COMMIT;

-- 確認
SELECT t.teacher_name, c.course_name
FROM teachers t
JOIN courses c ON t.teacher_id = c.teacher_id
WHERE t.teacher_id = 112;
```

### 解答29-2
```sql
-- ログテーブルの作成（実際の運用では事前に作成）
CREATE TABLE IF NOT EXISTS grade_change_log (
    log_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    student_id BIGINT,
    course_id VARCHAR(16),
    grade_type VARCHAR(32),
    old_score DECIMAL(5,2),
    new_score DECIMAL(5,2),
    change_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

START TRANSACTION;

-- 変更前のデータをログに記録
INSERT INTO grade_change_log (student_id, course_id, grade_type, old_score, new_score)
SELECT 
    student_id,
    course_id,
    grade_type,
    score,
    LEAST(score * 1.1, 100)
FROM grades
WHERE student_id = 301;

-- 成績にボーナスを加算
UPDATE grades
SET score = LEAST(score * 1.1, 100)
WHERE student_id = 301;

COMMIT;
```

### 解答29-3
```sql
START TRANSACTION;

-- 関連データを適切な順序で削除
DELETE FROM attendance 
WHERE schedule_id IN (
    SELECT schedule_id FROM course_schedule WHERE course_id = '32'
);

DELETE FROM grades WHERE course_id = '32';

DELETE FROM student_courses WHERE course_id = '32';

DELETE FROM course_schedule WHERE course_id = '32';

DELETE FROM courses WHERE course_id = '32';

-- 削除結果の確認
SELECT COUNT(*) as remaining_courses FROM courses WHERE course_id = '32';

COMMIT;
```

### 解答29-4
```sql
START TRANSACTION;

-- 学生の登録
INSERT INTO students (student_id, student_name) VALUES (346, 'セーブポイント学生');

-- セーブポイント設定
SAVEPOINT after_student_insert;

-- 受講登録の試行
BEGIN
    INSERT INTO student_courses (course_id, student_id) VALUES ('1', 346);
    INSERT INTO student_courses (course_id, student_id) VALUES ('2', 346);
    INSERT INTO student_courses (course_id, student_id) VALUES ('存在しない講座', 346);
EXCEPTION
    WHEN OTHERS THEN
        -- 受講登録でエラーが発生した場合、セーブポイントまでロールバック
        ROLLBACK TO after_student_insert;
        -- 学生情報は保持される
END;

COMMIT;

-- 確認
SELECT * FROM students WHERE student_id = 346;
SELECT * FROM student_courses WHERE student_id = 346;
```

### 解答29-5
```sql
START TRANSACTION;

-- 一時的な学生ID（999）を使用して安全に成績を入れ替え

-- Step 1: 301の成績を一時的に999に移動
UPDATE grades SET student_id = 999 WHERE student_id = 301;

-- Step 2: 302の成績を301に移動
UPDATE grades SET student_id = 301 WHERE student_id = 302;

-- Step 3: 999の成績を302に移動
UPDATE grades SET student_id = 302 WHERE student_id = 999;

-- 入れ替え完了の確認
SELECT 
    student_id,
    course_id,
    grade_type,
    score
FROM grades
WHERE student_id IN (301, 302)
ORDER BY student_id, course_id, grade_type;

COMMIT;
```

### 解答29-6
```sql
-- 通知テーブルの作成（実際の運用では事前に作成）
CREATE TABLE IF NOT EXISTS teacher_notifications (
    notification_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    teacher_id BIGINT,
    student_id BIGINT,
    message TEXT,
    notification_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_read BOOLEAN DEFAULT FALSE
);

-- 学生テーブルに警告フラグカラムを追加（実際の運用では事前に作成）
-- ALTER TABLE students ADD COLUMN warning_flag BOOLEAN DEFAULT FALSE;

START TRANSACTION;

-- 出席率が70%未満の学生に警告フラグを設定
UPDATE students s
SET warning_flag = TRUE
WHERE s.student_id IN (
    SELECT DISTINCT a.student_id
    FROM attendance a
    GROUP BY a.student_id
    HAVING AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) < 70
);

-- 担当教師への通知メッセージを作成
INSERT INTO teacher_notifications (teacher_id, student_id, message)
SELECT DISTINCT
    c.teacher_id,
    s.student_id,
    CONCAT('学生 ', s.student_name, '（ID: ', s.student_id, '）の出席率が70%を下回りました。面談が必要です。')
FROM students s
JOIN student_courses sc ON s.student_id = sc.student_id
JOIN courses c ON sc.course_id = c.course_id
WHERE s.warning_flag = TRUE;

COMMIT;

-- 確認
SELECT 
    s.student_name,
    s.warning_flag,
    t.teacher_name,
    tn.message
FROM students s
JOIN student_courses sc ON s.student_id = sc.student_id
JOIN courses c ON sc.course_id = c.course_id
JOIN teachers t ON c.teacher_id = t.teacher_id
LEFT JOIN teacher_notifications tn ON t.teacher_id = tn.teacher_id AND s.student_id = tn.student_id
WHERE s.warning_flag = TRUE;
```

## まとめ

この章では、トランザクションについて詳しく学びました：

1. **トランザクションの基本概念**：
   - 複数の操作をひとまとまりとして扱う仕組み
   - ACID特性（原子性、一貫性、独立性、永続性）
   - BEGIN/START TRANSACTION、COMMIT、ROLLBACKの使い方

2. **基本的なトランザクション操作**：
   - 学生登録と受講登録の組み合わせ
   - 成績の一括更新処理
   - エラー発生時のロールバック

3. **高度なトランザクション技術**：
   - 条件付きCOMMITとROLLBACK
   - セーブポイント（SAVEPOINT）の使用
   - 複雑な業務処理の実装

4. **同時実行制御**：
   - トランザクション分離レベル
   - デッドロックの理解と対策
   - オートコミットモードの制御

5. **実践的な応用**：
   - 学期末処理の自動化
   - データ整合性の保証
   - 複雑な業務ロジックの実装

6. **ベストプラクティス**：
   - 短時間でのトランザクション完了
   - 適切なエラーハンドリング
   - リソースの効率的な管理

トランザクションは、データベースの整合性を保つための重要な仕組みです。適切に使用することで、複雑な業務処理を安全かつ確実に実行できます。特に、複数のテーブルにまたがる処理や、エラーが発生した場合の復旧処理において、トランザクションは不可欠な機能です。

次の章では、「ビュー：仮想テーブルの作成と利用」について学び、複雑なクエリを再利用可能な形で管理する方法を理解していきます。

------------------------------------------------------------

# 30. ビュー：仮想テーブルの作成と利用

## はじめに

前章では、トランザクションを使って複数の操作を安全に実行する方法を学びました。この章では、複雑なクエリを再利用可能な形で管理するための「ビュー（View）」について学習します。

ビューは、一つまたは複数のテーブルから取得したデータを「仮想的なテーブル」として定義する機能です。実際のデータを格納するわけではなく、定義されたクエリを実行して動的に結果を生成します。

ビューが役立つ場面の例：
- 「複雑な集計クエリを何度も使いたい」
- 「機密情報を含むテーブルの一部だけを見せたい」
- 「複数のテーブルを結合した結果を簡単に参照したい」
- 「異なるユーザーに異なるデータの見せ方をしたい」
- 「レポート作成用の標準的なデータ形式を提供したい」
- 「複雑なビジネスロジックを隠蔽したい」

この章では、ビューの基本概念から実践的な活用方法、パフォーマンスの考慮点まで詳しく学んでいきます。

## ビューとは

ビューは、一つまたは複数のテーブルに基づいて定義される「仮想的なテーブル」です。ビュー自体はデータを格納せず、アクセス時に定義されたクエリを実行して結果を返します。

> **用語解説**：
> - **ビュー（View）**：テーブルやその他のビューに基づいて定義される仮想的なテーブルです。
> - **仮想テーブル**：実際のデータは格納せず、クエリの実行結果として動的に生成されるテーブルです。
> - **ベーステーブル**：ビューの定義で参照される元のテーブルです。
> - **更新可能ビュー**：INSERT、UPDATE、DELETEが可能なビューです。
> - **読み取り専用ビュー**：SELECT操作のみが可能なビューです。
> - **マテリアライズドビュー**：結果を物理的に格納するビュー（MySQLでは標準サポートなし）。

## ビューの利点

### 1. セキュリティの向上
機密情報を含むテーブルの一部のカラムやレコードのみを公開できます。

### 2. クエリの簡略化
複雑な結合や集計クエリを簡単な名前で参照できます。

### 3. データの論理的な統合
複数のテーブルから関連データを統合した形で提供できます。

### 4. データの抽象化
テーブル構造の変更をビューで吸収し、アプリケーションへの影響を最小化できます。

### 5. 再利用性
よく使用されるクエリパターンを標準化できます。

## ビューの基本構文

### CREATE VIEW文

```sql
CREATE VIEW ビュー名 AS
SELECT文;
```

### ビューの参照

```sql
SELECT * FROM ビュー名;
```

### ビューの削除

```sql
DROP VIEW ビュー名;
```

## 基本的なビューの例

### 例1：学生情報の簡略ビュー

学生の基本情報のみを表示するシンプルなビュー：

```sql
-- 学生基本情報ビューの作成
CREATE VIEW student_basic_info AS
SELECT 
    student_id,
    student_name
FROM students;

-- ビューの使用
SELECT * FROM student_basic_info;
```

実行結果：

| student_id | student_name |
|------------|--------------|
| 301        | 黒沢春馬     |
| 302        | 新垣愛留     |
| 303        | 柴崎春花     |
| ...        | ...          |

### 例2：講座と担当教師のビュー

講座と担当教師の情報を結合したビュー：

```sql
-- 講座詳細ビューの作成
CREATE VIEW course_details AS
SELECT 
    c.course_id,
    c.course_name,
    t.teacher_id,
    t.teacher_name,
    COUNT(sc.student_id) AS enrollment_count
FROM courses c
JOIN teachers t ON c.teacher_id = t.teacher_id
LEFT JOIN student_courses sc ON c.course_id = sc.course_id
GROUP BY c.course_id, c.course_name, t.teacher_id, t.teacher_name;

-- ビューの使用
SELECT * FROM course_details 
WHERE enrollment_count > 10
ORDER BY enrollment_count DESC;
```

実行結果：

| course_id | course_name           | teacher_id | teacher_name | enrollment_count |
|-----------|----------------------|------------|--------------|------------------|
| 1         | ITのための基礎知識     | 101        | 寺内鞍       | 12               |
| 16        | データサイエンスとビジネス応用 | 106 | 星野涼子     | 11               |
| ...       | ...                  | ...        | ...          | ...              |

## 複雑なビューの例

### 例3：学生の成績サマリービュー

各学生の成績統計を表示するビュー：

```sql
CREATE VIEW student_grade_summary AS
SELECT 
    s.student_id,
    s.student_name,
    COUNT(DISTINCT g.course_id) AS courses_taken,
    COUNT(g.grade_id) AS total_grades,
    ROUND(AVG(g.score), 2) AS average_score,
    MAX(g.score) AS highest_score,
    MIN(g.score) AS lowest_score,
    CASE 
        WHEN AVG(g.score) >= 90 THEN 'A'
        WHEN AVG(g.score) >= 80 THEN 'B'
        WHEN AVG(g.score) >= 70 THEN 'C'
        WHEN AVG(g.score) >= 60 THEN 'D'
        ELSE 'F'
    END AS overall_grade
FROM students s
LEFT JOIN grades g ON s.student_id = g.student_id
GROUP BY s.student_id, s.student_name;

-- ビューの使用
SELECT * FROM student_grade_summary 
WHERE overall_grade IN ('A', 'B')
ORDER BY average_score DESC;
```

### 例4：出席率統計ビュー

各学生の出席状況を統計表示するビュー：

```sql
CREATE VIEW attendance_statistics AS
SELECT 
    s.student_id,
    s.student_name,
    COUNT(a.schedule_id) AS total_classes,
    SUM(CASE WHEN a.status = 'present' THEN 1 ELSE 0 END) AS present_count,
    SUM(CASE WHEN a.status = 'late' THEN 1 ELSE 0 END) AS late_count,
    SUM(CASE WHEN a.status = 'absent' THEN 1 ELSE 0 END) AS absent_count,
    ROUND(AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END), 1) AS attendance_rate,
    CASE 
        WHEN AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) >= 95 THEN '優秀'
        WHEN AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) >= 85 THEN '良好'
        WHEN AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) >= 75 THEN '普通'
        ELSE '要改善'
    END AS attendance_status
FROM students s
LEFT JOIN attendance a ON s.student_id = a.student_id
GROUP BY s.student_id, s.student_name;

-- ビューの使用
SELECT student_name, attendance_rate, attendance_status
FROM attendance_statistics 
WHERE attendance_status = '要改善'
ORDER BY attendance_rate;
```

### 例5：総合ダッシュボードビュー

成績と出席率を統合した総合評価ビュー：

```sql
CREATE VIEW student_dashboard AS
SELECT 
    sgs.student_id,
    sgs.student_name,
    sgs.average_score,
    sgs.overall_grade,
    ats.attendance_rate,
    ats.attendance_status,
    CASE 
        WHEN sgs.overall_grade IN ('A', 'B') AND ats.attendance_rate >= 85 THEN '優秀学生'
        WHEN sgs.overall_grade IN ('A', 'B', 'C') AND ats.attendance_rate >= 75 THEN '良好学生'
        WHEN sgs.overall_grade = 'F' OR ats.attendance_rate < 60 THEN '要指導学生'
        ELSE '一般学生'
    END AS student_category,
    sgs.courses_taken,
    ats.total_classes
FROM student_grade_summary sgs
LEFT JOIN attendance_statistics ats ON sgs.student_id = ats.student_id;

-- ビューの使用
SELECT 
    student_category,
    COUNT(*) as student_count,
    ROUND(AVG(average_score), 1) as avg_grade,
    ROUND(AVG(attendance_rate), 1) as avg_attendance
FROM student_dashboard
GROUP BY student_category
ORDER BY avg_grade DESC;
```

## 更新可能ビューと更新不可能ビュー

### 更新可能ビューの条件

ビューがINSERT、UPDATE、DELETEを受け付けるには、以下の条件を満たす必要があります：

1. 単一のテーブルを参照している
2. GROUP BY、HAVING、集計関数を使用していない
3. DISTINCT、UNION、サブクエリを使用していない
4. 計算カラムがない

### 例6：更新可能ビューの作成と使用

```sql
-- 更新可能ビューの作成
CREATE VIEW active_students AS
SELECT student_id, student_name
FROM students
WHERE student_id >= 300;

-- ビューを通じた挿入
INSERT INTO active_students (student_id, student_name)
VALUES (347, 'ビューテスト学生');

-- ビューを通じた更新
UPDATE active_students
SET student_name = 'ビューテスト学生（更新済み）'
WHERE student_id = 347;

-- ビューを通じた削除
DELETE FROM active_students WHERE student_id = 347;

-- 確認
SELECT * FROM active_students WHERE student_id = 347;
```

### 例7：更新不可能ビューの例

```sql
-- 更新不可能ビュー（集計関数を使用）
CREATE VIEW course_enrollment_count AS
SELECT 
    c.course_id,
    c.course_name,
    COUNT(sc.student_id) as enrollment_count
FROM courses c
LEFT JOIN student_courses sc ON c.course_id = sc.course_id
GROUP BY c.course_id, c.course_name;

-- このビューに対するUPDATEは失敗する
-- UPDATE course_enrollment_count SET enrollment_count = 10 WHERE course_id = '1';
-- エラー: The target table course_enrollment_count of the UPDATE is not updatable
```

## WITH CHECK OPTIONの使用

WHERE句を含むビューで、条件に合わないデータの挿入を防ぐために使用します。

### 例8：WITH CHECK OPTIONの使用

```sql
-- チェックオプション付きビューの作成
CREATE VIEW high_grade_students AS
SELECT student_id, student_name
FROM students
WHERE student_id IN (
    SELECT DISTINCT student_id 
    FROM grades 
    WHERE score >= 80
)
WITH CHECK OPTION;

-- このビューを通じた挿入は、条件をチェックする
-- INSERT INTO high_grade_students VALUES (999, '新学生');
-- この場合、成績が80点以上でないとエラーになる
```

## セキュリティビューの例

### 例9：機密情報を隠すビュー

教師用の学生情報ビュー（個人情報の一部を制限）：

```sql
-- 教師用学生情報ビュー（制限付き）
CREATE VIEW teacher_student_view AS
SELECT 
    s.student_id,
    LEFT(s.student_name, 1) + '**' AS masked_name,  -- 名前をマスク
    sgs.average_score,
    sgs.overall_grade,
    ats.attendance_rate
FROM students s
LEFT JOIN student_grade_summary sgs ON s.student_id = sgs.student_id
LEFT JOIN attendance_statistics ats ON s.student_id = ats.student_id;

-- 管理者用学生情報ビュー（制限なし）
CREATE VIEW admin_student_view AS
SELECT 
    s.student_id,
    s.student_name,
    sgs.average_score,
    sgs.overall_grade,
    ats.attendance_rate,
    ats.total_classes,
    sgs.courses_taken
FROM students s
LEFT JOIN student_grade_summary sgs ON s.student_id = sgs.student_id
LEFT JOIN attendance_statistics ats ON s.student_id = ats.student_id;
```

## 複雑なレポートビューの例

### 例10：月次レポートビュー

```sql
CREATE VIEW monthly_report AS
SELECT 
    DATE_FORMAT(cs.schedule_date, '%Y-%m') AS report_month,
    COUNT(DISTINCT cs.schedule_id) AS total_classes,
    COUNT(DISTINCT cs.course_id) AS active_courses,
    COUNT(DISTINCT cs.teacher_id) AS active_teachers,
    COUNT(DISTINCT a.student_id) AS attending_students,
    ROUND(AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END), 1) AS average_attendance_rate,
    COUNT(CASE WHEN a.status = 'present' THEN 1 END) AS total_attendance,
    COUNT(CASE WHEN a.status = 'absent' THEN 1 END) AS total_absences,
    COUNT(CASE WHEN a.status = 'late' THEN 1 END) AS total_late
FROM course_schedule cs
LEFT JOIN attendance a ON cs.schedule_id = a.schedule_id
WHERE cs.schedule_date >= '2025-01-01'
GROUP BY DATE_FORMAT(cs.schedule_date, '%Y-%m')
ORDER BY report_month;

-- 月次レポートの確認
SELECT * FROM monthly_report;
```

### 例11：教師パフォーマンスビュー

```sql
CREATE VIEW teacher_performance AS
SELECT 
    t.teacher_id,
    t.teacher_name,
    COUNT(DISTINCT c.course_id) AS courses_taught,
    COUNT(DISTINCT sc.student_id) AS total_students,
    ROUND(AVG(g.score), 2) AS average_student_score,
    ROUND(AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END), 1) AS class_attendance_rate,
    COUNT(DISTINCT cs.schedule_id) AS classes_held,
    CASE 
        WHEN AVG(g.score) >= 85 AND AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) >= 90 THEN '優秀'
        WHEN AVG(g.score) >= 75 AND AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) >= 80 THEN '良好'
        ELSE '標準'
    END AS performance_rating
FROM teachers t
LEFT JOIN courses c ON t.teacher_id = c.teacher_id
LEFT JOIN student_courses sc ON c.course_id = sc.course_id
LEFT JOIN grades g ON c.course_id = g.course_id
LEFT JOIN course_schedule cs ON c.course_id = cs.course_id
LEFT JOIN attendance a ON cs.schedule_id = a.schedule_id
GROUP BY t.teacher_id, t.teacher_name;

-- 教師パフォーマンスの確認
SELECT * FROM teacher_performance 
ORDER BY performance_rating, average_student_score DESC;
```

## ビューの管理

### ビューの変更

```sql
-- ビューの定義を変更
CREATE OR REPLACE VIEW student_basic_info AS
SELECT 
    student_id,
    student_name,
    'アクティブ' AS status  -- 新しいカラムを追加
FROM students
WHERE student_id >= 300;
```

### ビューの削除

```sql
-- ビューの削除
DROP VIEW IF EXISTS student_basic_info;
```

### ビューの情報確認

```sql
-- 存在するビューの一覧
SHOW TABLES;

-- ビューの詳細情報
SHOW CREATE VIEW student_dashboard;

-- ビューの構造確認
DESCRIBE student_dashboard;
```

## ビューのパフォーマンス考慮点

### 1. 複雑なビューのパフォーマンス

```sql
-- パフォーマンスが重い可能性があるビュー
CREATE VIEW complex_student_analysis AS
SELECT 
    s.student_id,
    s.student_name,
    (SELECT AVG(score) FROM grades WHERE student_id = s.student_id) AS avg_score,
    (SELECT COUNT(*) FROM attendance WHERE student_id = s.student_id) AS total_classes,
    (SELECT COUNT(DISTINCT course_id) FROM student_courses WHERE student_id = s.student_id) AS course_count
FROM students s;

-- より効率的な書き方
CREATE VIEW efficient_student_analysis AS
SELECT 
    s.student_id,
    s.student_name,
    ROUND(AVG(g.score), 2) AS avg_score,
    COUNT(DISTINCT a.schedule_id) AS total_classes,
    COUNT(DISTINCT sc.course_id) AS course_count
FROM students s
LEFT JOIN grades g ON s.student_id = g.student_id
LEFT JOIN attendance a ON s.student_id = a.student_id
LEFT JOIN student_courses sc ON s.student_id = sc.student_id
GROUP BY s.student_id, s.student_name;
```

### 2. インデックスの重要性

ビューで使用されるベーステーブルのカラムに適切なインデックスを作成：

```sql
-- ビューのパフォーマンス向上のためのインデックス
-- CREATE INDEX idx_grades_student_id ON grades(student_id);
-- CREATE INDEX idx_attendance_student_id ON attendance(student_id);
-- CREATE INDEX idx_student_courses_student_id ON student_courses(student_id);
```

## ビューのベストプラクティス

### 1. 命名規則

```sql
-- わかりやすい命名規則を使用
CREATE VIEW v_student_summary AS        -- プレフィックス付き
SELECT ...;

CREATE VIEW student_grade_report AS     -- 用途が明確
SELECT ...;
```

### 2. ドキュメント化

```sql
-- コメント付きビューの作成
CREATE VIEW student_performance_metrics AS
-- 目的: 学生のパフォーマンス指標を統合表示
-- 作成者: 管理者
-- 作成日: 2025-05-22
-- 更新日: 2025-05-22
SELECT 
    s.student_id,
    s.student_name,
    -- 成績関連指標
    AVG(g.score) AS average_score,
    -- 出席関連指標
    AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) AS attendance_rate
FROM students s
LEFT JOIN grades g ON s.student_id = g.student_id
LEFT JOIN attendance a ON s.student_id = a.student_id
GROUP BY s.student_id, s.student_name;
```

### 3. 段階的なビュー構築

```sql
-- 基本ビュー
CREATE VIEW basic_student_info AS
SELECT student_id, student_name FROM students;

-- 拡張ビュー（基本ビューを利用）
CREATE VIEW extended_student_info AS
SELECT 
    bsi.*,
    COUNT(sc.course_id) AS course_count
FROM basic_student_info bsi
LEFT JOIN student_courses sc ON bsi.student_id = sc.student_id
GROUP BY bsi.student_id, bsi.student_name;
```

## 実践的なビュー活用例

### 例12：API用データビュー

アプリケーション向けのJSON形式データを提供するビュー：

```sql
CREATE VIEW api_student_data AS
SELECT 
    JSON_OBJECT(
        'student_id', s.student_id,
        'name', s.student_name,
        'grades', JSON_OBJECT(
            'average', ROUND(AVG(g.score), 2),
            'count', COUNT(g.grade_id)
        ),
        'attendance', JSON_OBJECT(
            'rate', ROUND(AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END), 1),
            'total_classes', COUNT(a.schedule_id)
        )
    ) AS student_data
FROM students s
LEFT JOIN grades g ON s.student_id = g.student_id
LEFT JOIN attendance a ON s.student_id = a.student_id
GROUP BY s.student_id, s.student_name;
```

## 練習問題

### 問題30-1
各講座の基本情報（講座ID、講座名、担当教師名、受講者数）を表示するビュー「course_overview」を作成してください。

### 問題30-2
学生の出席率が80%以上の学生のみを表示するビュー「good_attendance_students」を作成してください。このビューには学生ID、学生名、出席率を含めてください。

### 問題30-3
各教師について、担当講座数、総受講者数、担当講座の平均成績を表示するビュー「teacher_summary」を作成してください。

### 問題30-4
成績が85点以上の学生のみが更新可能な制限付きビュー「high_performers」を作成してください。WITH CHECK OPTIONを使用してください。

### 問題30-5
月別の授業統計（年月、実施授業数、出席者総数、平均出席率）を表示するビュー「monthly_class_stats」を作成してください。

### 問題30-6
学生、成績、出席率の情報を統合し、総合評価（S、A、B、C、D）を算出するビュー「student_comprehensive_evaluation」を作成してください。評価基準は以下の通りです：
- S: 平均点90点以上かつ出席率95%以上
- A: 平均点80点以上かつ出席率85%以上
- B: 平均点70点以上かつ出席率75%以上  
- C: 平均点60点以上かつ出席率65%以上
- D: 上記以外

## 解答

### 解答30-1
```sql
CREATE VIEW course_overview AS
SELECT 
    c.course_id,
    c.course_name,
    t.teacher_name,
    COUNT(sc.student_id) AS enrollment_count
FROM courses c
JOIN teachers t ON c.teacher_id = t.teacher_id
LEFT JOIN student_courses sc ON c.course_id = sc.course_id
GROUP BY c.course_id, c.course_name, t.teacher_name;

-- 確認
SELECT * FROM course_overview ORDER BY enrollment_count DESC;
```

### 解答30-2
```sql
CREATE VIEW good_attendance_students AS
SELECT 
    s.student_id,
    s.student_name,
    ROUND(AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END), 1) AS attendance_rate
FROM students s
JOIN attendance a ON s.student_id = a.student_id
GROUP BY s.student_id, s.student_name
HAVING AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) >= 80;

-- 確認
SELECT * FROM good_attendance_students ORDER BY attendance_rate DESC;
```

### 解答30-3
```sql
CREATE VIEW teacher_summary AS
SELECT 
    t.teacher_id,
    t.teacher_name,
    COUNT(DISTINCT c.course_id) AS courses_taught,
    COUNT(DISTINCT sc.student_id) AS total_students,
    ROUND(AVG(g.score), 2) AS average_grade
FROM teachers t
LEFT JOIN courses c ON t.teacher_id = c.teacher_id
LEFT JOIN student_courses sc ON c.course_id = sc.course_id
LEFT JOIN grades g ON c.course_id = g.course_id
GROUP BY t.teacher_id, t.teacher_name;

-- 確認
SELECT * FROM teacher_summary ORDER BY average_grade DESC;
```

### 解答30-4
```sql
CREATE VIEW high_performers AS
SELECT 
    s.student_id,
    s.student_name
FROM students s
WHERE s.student_id IN (
    SELECT student_id
    FROM grades
    GROUP BY student_id
    HAVING AVG(score) >= 85
)
WITH CHECK OPTION;

-- 使用例（平均85点以上の学生のみ追加可能）
-- INSERT INTO high_performers VALUES (999, 'テスト学生');
```

### 解答30-5
```sql
CREATE VIEW monthly_class_stats AS
SELECT 
    DATE_FORMAT(cs.schedule_date, '%Y-%m') AS month_year,
    COUNT(DISTINCT cs.schedule_id) AS classes_held,
    COUNT(CASE WHEN a.status = 'present' THEN 1 END) AS total_attendance,
    ROUND(AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END), 1) AS average_attendance_rate
FROM course_schedule cs
LEFT JOIN attendance a ON cs.schedule_id = a.schedule_id
GROUP BY DATE_FORMAT(cs.schedule_date, '%Y-%m')
ORDER BY month_year;

-- 確認
SELECT * FROM monthly_class_stats;
```

### 解答30-6
```sql
CREATE VIEW student_comprehensive_evaluation AS
SELECT 
    s.student_id,
    s.student_name,
    ROUND(AVG(g.score), 2) AS average_score,
    ROUND(AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END), 1) AS attendance_rate,
    CASE 
        WHEN AVG(g.score) >= 90 AND AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) >= 95 THEN 'S'
        WHEN AVG(g.score) >= 80 AND AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) >= 85 THEN 'A'
        WHEN AVG(g.score) >= 70 AND AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) >= 75 THEN 'B'
        WHEN AVG(g.score) >= 60 AND AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END) >= 65 THEN 'C'
        ELSE 'D'
    END AS comprehensive_grade
FROM students s
LEFT JOIN grades g ON s.student_id = g.student_id
LEFT JOIN attendance a ON s.student_id = a.student_id
GROUP BY s.student_id, s.student_name;

-- 確認
SELECT 
    comprehensive_grade,
    COUNT(*) as student_count,
    ROUND(AVG(average_score), 1) as avg_score,
    ROUND(AVG(attendance_rate), 1) as avg_attendance
FROM student_comprehensive_evaluation
GROUP BY comprehensive_grade
ORDER BY comprehensive_grade;
```

## まとめ

この章では、ビューについて詳しく学びました：

1. **ビューの基本概念**：
   - 仮想テーブルとしてのビューの理解
   - ベーステーブルとの関係
   - セキュリティと簡略化の利点

2. **基本的なビューの作成**：
   - CREATE VIEW文の構文
   - シンプルなビューの例
   - 複数テーブルの結合ビュー

3. **複雑なビューの活用**：
   - 集計関数を使ったビュー
   - 条件分岐を含むビュー
   - 複数ビューの組み合わせ

4. **更新可能ビュー**：
   - 更新可能な条件の理解
   - WITH CHECK OPTIONの使用
   - セキュリティ制限の実装

5. **実践的な応用**：
   - ダッシュボードビューの作成
   - レポート用ビューの構築
   - API用データビューの設計

6. **ビューの管理**：
   - ビューの変更と削除
   - 情報確認の方法
   - 適切な命名規則

7. **パフォーマンス考慮点**：
   - 効率的なビューの設計
   - インデックスの重要性
   - 複雑さとパフォーマンスのバランス

8. **ベストプラクティス**：
   - 段階的なビュー構築
   - ドキュメント化の重要性
   - 保守性の向上

ビューは、データベースの複雑さを隠蔽し、ユーザーに使いやすいインターフェースを提供する強力な機能です。適切に設計・活用することで、セキュリティの向上、開発効率の向上、保守性の向上を実現できます。

次の章では、「インデックス：検索効率化の基本」について学び、データベースのパフォーマンスを向上させる方法を理解していきます。

------------------------------------------------------------

# 31. インデックス：検索効率化の基本

## はじめに

前章では、ビューを使って複雑なクエリを管理しやすくする方法を学びました。この章では、データベースの検索性能を大幅に向上させる「インデックス」について学習します。

インデックスは、データベースのパフォーマンスを左右する最も重要な要素の一つです。適切に設計されたインデックスは、検索速度を数十倍、場合によっては数百倍高速化することができます。

インデックスが重要な場面の例：
- 「学生IDでの検索が遅すぎる」
- 「成績順でのソートに時間がかかる」
- 「複数テーブルの結合処理が遅い」
- 「WHERE句での絞り込みが非効率」
- 「大量データでの集計処理が重い」
- 「アプリケーションの応答時間を改善したい」

この章では、インデックスの基本概念から実践的な設計方法、パフォーマンス分析まで詳しく学んでいきます。

## インデックスとは

インデックスは、データベースの検索性能を向上させるための「索引」です。本の巻末にある索引と同様に、特定の値を効率的に見つけるための仕組みです。

> **用語解説**：
> - **インデックス（Index）**：テーブルのデータを効率的に検索するための索引構造です。
> - **B-Treeインデックス**：最も一般的なインデックス構造で、バランス木を使用します。
> - **主キー（Primary Key）**：テーブルの各行を一意に識別するキーで、自動的にインデックスが作成されます。
> - **外部キー（Foreign Key）**：他のテーブルの主キーを参照するキーです。
> - **一意インデックス（Unique Index）**：重複値を許可しないインデックスです。
> - **複合インデックス（Composite Index）**：複数のカラムを組み合わせたインデックスです。
> - **選択性（Selectivity）**：インデックスがどれだけ効果的にデータを絞り込めるかの指標です。

## インデックスの仕組み

### 本の索引との比較

本で特定の用語を探す場合：
- **索引なし**：最初のページから順番に全ページをめくって探す
- **索引あり**：巻末の索引で用語を見つけ、該当ページに直接飛ぶ

データベースでも同様：
- **インデックスなし**：テーブルの最初の行から順番に全行をスキャン（フルテーブルスキャン）
- **インデックスあり**：インデックスで該当行を特定し、直接アクセス

### B-Treeインデックスの構造

```
        [50]
       /    \
   [25]      [75]
   /  \      /  \
[10][40] [60][90]
```

この木構造により、対数時間（O(log n)）でのデータアクセスが可能になります。

## インデックスの種類

### 1. 主キーインデックス（自動作成）

```sql
-- 主キーは自動的にインデックスが作成される
CREATE TABLE test_students (
    student_id BIGINT PRIMARY KEY,  -- 自動的にインデックス作成
    student_name VARCHAR(64)
);
```

### 2. 一意インデックス

```sql
-- 重複を許可しないインデックス
CREATE UNIQUE INDEX idx_student_email 
ON students (email);
```

### 3. 単一カラムインデックス

```sql
-- 単一カラムのインデックス
CREATE INDEX idx_student_name 
ON students (student_name);

CREATE INDEX idx_grades_score 
ON grades (score);
```

### 4. 複合インデックス

```sql
-- 複数カラムの組み合わせインデックス
CREATE INDEX idx_grades_student_course 
ON grades (student_id, course_id);

CREATE INDEX idx_attendance_schedule_student 
ON attendance (schedule_id, student_id, status);
```

## インデックスの作成

### CREATE INDEX文の基本構文

```sql
CREATE [UNIQUE] INDEX インデックス名
ON テーブル名 (カラム1 [ASC|DESC], カラム2 [ASC|DESC], ...);
```

### 例1：学校データベースでの基本インデックス作成

```sql
-- 学生名での検索を高速化
CREATE INDEX idx_students_name ON students (student_name);

-- 成績での検索を高速化
CREATE INDEX idx_grades_score ON grades (score);

-- 授業日での検索を高速化
CREATE INDEX idx_schedule_date ON course_schedule (schedule_date);

-- 教師IDでの検索を高速化（既存の外部キーに追加）
CREATE INDEX idx_courses_teacher ON courses (teacher_id);
```

### 例2：複合インデックスの作成

```sql
-- 学生と講座の組み合わせでの検索を高速化
CREATE INDEX idx_grades_student_course ON grades (student_id, course_id);

-- 講座と評価タイプの組み合わせでの検索を高速化
CREATE INDEX idx_grades_course_type ON grades (course_id, grade_type);

-- 日付と時限の組み合わせでの検索を高速化
CREATE INDEX idx_schedule_date_period ON course_schedule (schedule_date, period_id);
```

## インデックスの効果を確認

### EXPLAIN文によるクエリ実行計画の確認

```sql
-- インデックスを使用する前のクエリ
EXPLAIN
SELECT * FROM grades WHERE student_id = 301;

-- インデックス作成
CREATE INDEX idx_grades_student_id ON grades (student_id);

-- インデックスを使用した後のクエリ
EXPLAIN
SELECT * FROM grades WHERE student_id = 301;
```

### 例3：パフォーマンス改善の実例

**改善前：**
```sql
-- インデックスなしでの検索（遅い）
SELECT s.student_name, g.score
FROM students s
JOIN grades g ON s.student_id = g.student_id
WHERE g.score >= 85
ORDER BY g.score DESC;

-- EXPLAIN結果: Full Table Scan（全テーブルスキャン）
```

**改善後：**
```sql
-- 適切なインデックスを作成
CREATE INDEX idx_grades_score ON grades (score);
CREATE INDEX idx_grades_student_id ON grades (student_id);

-- 同じクエリが高速化される
SELECT s.student_name, g.score
FROM students s
JOIN grades g ON s.student_id = g.student_id
WHERE g.score >= 85
ORDER BY g.score DESC;

-- EXPLAIN結果: Index Scan（インデックススキャン）
```

## 複合インデックスの設計

### カラムの順序の重要性

複合インデックスでは、カラムの順序が非常に重要です。「左端一致の原則」に従って設計する必要があります。

```sql
-- 複合インデックスの作成
CREATE INDEX idx_grades_multi ON grades (student_id, course_id, grade_type);

-- このインデックスが効果的に使用される例
SELECT * FROM grades WHERE student_id = 301;  -- ✓ 効果的
SELECT * FROM grades WHERE student_id = 301 AND course_id = '1';  -- ✓ 効果的
SELECT * FROM grades WHERE student_id = 301 AND course_id = '1' AND grade_type = '中間テスト';  -- ✓ 効果的

-- このインデックスが効果的でない例
SELECT * FROM grades WHERE course_id = '1';  -- ✗ 効果的でない
SELECT * FROM grades WHERE grade_type = '中間テスト';  -- ✗ 効果的でない
SELECT * FROM grades WHERE course_id = '1' AND grade_type = '中間テスト';  -- ✗ 効果的でない
```

### 例4：効果的な複合インデックスの設計

```sql
-- 出席検索用の複合インデックス
-- よく使用される検索パターンを分析
-- 1. schedule_id での検索
-- 2. schedule_id + student_id での検索
-- 3. schedule_id + student_id + status での検索

CREATE INDEX idx_attendance_composite 
ON attendance (schedule_id, student_id, status);

-- 効果的な使用例
EXPLAIN SELECT * FROM attendance 
WHERE schedule_id = 1 AND student_id = 301;

EXPLAIN SELECT COUNT(*) FROM attendance 
WHERE schedule_id = 1 AND status = 'present';
```

## 実践的なインデックス設計例

### 例5：学生検索の最適化

```sql
-- 学生検索でよく使用されるクエリパターンを分析

-- パターン1: 名前での部分一致検索
SELECT * FROM students WHERE student_name LIKE '田%';

-- パターン2: IDでの直接検索
SELECT * FROM students WHERE student_id = 301;

-- パターン3: 範囲での検索
SELECT * FROM students WHERE student_id BETWEEN 301 AND 310;

-- 対応するインデックス
CREATE INDEX idx_students_name ON students (student_name);  -- 主キーは既存
-- student_id は主キーなので既にインデックスあり
```

### 例6：成績分析クエリの最適化

```sql
-- よく使用される成績分析クエリ
-- 1. 特定学生の全成績
SELECT * FROM grades WHERE student_id = 301;

-- 2. 特定講座の全成績
SELECT * FROM grades WHERE course_id = '1';

-- 3. 特定評価タイプの全成績
SELECT * FROM grades WHERE grade_type = '中間テスト';

-- 4. 高得点の成績
SELECT * FROM grades WHERE score >= 90;

-- 5. 学生×講座での成績
SELECT * FROM grades WHERE student_id = 301 AND course_id = '1';

-- 最適なインデックス設計
CREATE INDEX idx_grades_student_id ON grades (student_id);
CREATE INDEX idx_grades_course_id ON grades (course_id);
CREATE INDEX idx_grades_score ON grades (score);
CREATE INDEX idx_grades_student_course ON grades (student_id, course_id);
```

### 例7：授業スケジュール検索の最適化

```sql
-- スケジュール検索のクエリパターン
-- 1. 特定日の授業
SELECT * FROM course_schedule WHERE schedule_date = '2025-05-22';

-- 2. 特定期間の授業
SELECT * FROM course_schedule 
WHERE schedule_date BETWEEN '2025-05-01' AND '2025-05-31';

-- 3. 特定講座のスケジュール
SELECT * FROM course_schedule WHERE course_id = '1';

-- 4. 特定教師のスケジュール
SELECT * FROM course_schedule WHERE teacher_id = 101;

-- 5. 日付と時限での検索
SELECT * FROM course_schedule 
WHERE schedule_date = '2025-05-22' AND period_id = 1;

-- 最適なインデックス設計
CREATE INDEX idx_schedule_date ON course_schedule (schedule_date);
CREATE INDEX idx_schedule_course ON course_schedule (course_id);
CREATE INDEX idx_schedule_teacher ON course_schedule (teacher_id);
CREATE INDEX idx_schedule_date_period ON course_schedule (schedule_date, period_id);
```

## インデックスのパフォーマンス分析

### EXPLAIN文の詳細分析

```sql
-- 詳細な実行計画の確認
EXPLAIN FORMAT=JSON
SELECT s.student_name, AVG(g.score) as avg_score
FROM students s
JOIN grades g ON s.student_id = g.student_id
WHERE g.score >= 80
GROUP BY s.student_id, s.student_name
ORDER BY avg_score DESC;
```

### 例8：結合クエリの最適化

```sql
-- 結合処理の最適化前
EXPLAIN
SELECT s.student_name, c.course_name, g.score
FROM students s
JOIN student_courses sc ON s.student_id = sc.student_id
JOIN courses c ON sc.course_id = c.course_id
JOIN grades g ON s.student_id = g.student_id AND c.course_id = g.course_id
WHERE g.score >= 85;

-- 結合用インデックスの作成
CREATE INDEX idx_student_courses_student ON student_courses (student_id);
CREATE INDEX idx_student_courses_course ON student_courses (course_id);
CREATE INDEX idx_grades_student_course_score ON grades (student_id, course_id, score);

-- 最適化後のクエリ
EXPLAIN
SELECT s.student_name, c.course_name, g.score
FROM students s
JOIN student_courses sc ON s.student_id = sc.student_id
JOIN courses c ON sc.course_id = c.course_id
JOIN grades g ON s.student_id = g.student_id AND c.course_id = g.course_id
WHERE g.score >= 85;
```

## インデックスのコストと注意点

### 1. 挿入・更新・削除への影響

```sql
-- インデックスが多いテーブルでは、更新処理が遅くなる
-- 例：grades テーブルに多数のインデックスがある場合

-- 挿入時：すべてのインデックスを更新する必要がある
INSERT INTO grades (student_id, course_id, grade_type, score, max_score)
VALUES (301, '1', '追加テスト', 85, 100);

-- 更新時：影響するインデックスを更新する必要がある
UPDATE grades SET score = 90 WHERE student_id = 301 AND course_id = '1';

-- 削除時：すべてのインデックスから該当エントリを削除する必要がある
DELETE FROM grades WHERE student_id = 301 AND course_id = '1';
```

### 2. ストレージ使用量の増加

```sql
-- インデックスのサイズ確認
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    ROUND(STAT_VALUE * @@innodb_page_size / 1024 / 1024, 2) AS index_size_mb
FROM INFORMATION_SCHEMA.INNODB_SYS_TABLESTATS 
WHERE TABLE_NAME LIKE 'grades';
```

### 3. 不要なインデックスの識別

```sql
-- 使用されていないインデックスの確認
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_STAR,
    COUNT_READ,
    COUNT_WRITE
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'school_db'
AND COUNT_STAR = 0
ORDER BY OBJECT_NAME, INDEX_NAME;
```

## 効果的でないインデックスの例

### 避けるべきインデックス

```sql
-- 1. 選択性の低いカラム（多くの行が同じ値）
-- 悪い例：ほとんどの値が同じ
CREATE INDEX idx_grades_max_score ON grades (max_score);  -- ほとんど100

-- 2. 頻繁に更新されるカラム
-- 注意が必要：頻繁に更新される場合
CREATE INDEX idx_grades_submission_date ON grades (submission_date);

-- 3. 非常に長い文字列カラム
-- 注意が必要：長いテキストフィールド
CREATE INDEX idx_classrooms_facilities ON classrooms (facilities);  -- TEXT型
```

### 部分インデックスの活用

```sql
-- 部分インデックス（特定の条件に一致するレコードのみ）
CREATE INDEX idx_high_scores ON grades (student_id, score) 
WHERE score >= 80;

-- NULL値を除外したインデックス
CREATE INDEX idx_non_null_scores ON grades (score) 
WHERE score IS NOT NULL;
```

## インデックスの保守

### インデックスの確認

```sql
-- テーブルのインデックス一覧表示
SHOW INDEX FROM grades;

-- より詳細な情報
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    COLUMN_NAME,
    SEQ_IN_INDEX,
    COLLATION,
    CARDINALITY,
    INDEX_TYPE
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = 'school_db' 
AND TABLE_NAME = 'grades'
ORDER BY INDEX_NAME, SEQ_IN_INDEX;
```

### インデックスの削除

```sql
-- 不要なインデックスの削除
DROP INDEX idx_grades_max_score ON grades;

-- 主キー以外のインデックスをすべて削除
ALTER TABLE grades 
DROP INDEX idx_grades_score,
DROP INDEX idx_grades_student_id,
DROP INDEX idx_grades_course_id;
```

### インデックスの再構築

```sql
-- テーブルの最適化（インデックス再構築を含む）
OPTIMIZE TABLE grades;

-- または
ALTER TABLE grades ENGINE=InnoDB;
```

## 実践的なインデックス戦略

### 例9：学校データベースの包括的なインデックス設計

```sql
-- 1. 基本的な検索パターンに対するインデックス

-- 学生関連
CREATE INDEX idx_students_name ON students (student_name);

-- 講座関連
CREATE INDEX idx_courses_teacher ON courses (teacher_id);
CREATE INDEX idx_courses_name ON courses (course_name);

-- 成績関連
CREATE INDEX idx_grades_student ON grades (student_id);
CREATE INDEX idx_grades_course ON grades (course_id);
CREATE INDEX idx_grades_score ON grades (score);
CREATE INDEX idx_grades_type ON grades (grade_type);
CREATE INDEX idx_grades_date ON grades (submission_date);

-- 複合インデックス
CREATE INDEX idx_grades_student_course ON grades (student_id, course_id);
CREATE INDEX idx_grades_course_type_score ON grades (course_id, grade_type, score);

-- 出席関連
CREATE INDEX idx_attendance_student ON attendance (student_id);
CREATE INDEX idx_attendance_schedule ON attendance (schedule_id);
CREATE INDEX idx_attendance_status ON attendance (status);
CREATE INDEX idx_attendance_schedule_student ON attendance (schedule_id, student_id);

-- スケジュール関連
CREATE INDEX idx_schedule_date ON course_schedule (schedule_date);
CREATE INDEX idx_schedule_course ON course_schedule (course_id);
CREATE INDEX idx_schedule_teacher ON course_schedule (teacher_id);
CREATE INDEX idx_schedule_classroom ON course_schedule (classroom_id);
CREATE INDEX idx_schedule_date_period ON course_schedule (schedule_date, period_id);

-- 受講関連
CREATE INDEX idx_student_courses_student ON student_courses (student_id);
CREATE INDEX idx_student_courses_course ON student_courses (course_id);
```

### 例10：クエリパフォーマンスの測定

```sql
-- パフォーマンステスト用のクエリ
SET profiling = 1;

-- テストクエリ1：学生の成績検索
SELECT s.student_name, AVG(g.score) as avg_score
FROM students s
JOIN grades g ON s.student_id = g.student_id
WHERE s.student_id BETWEEN 301 AND 310
GROUP BY s.student_id, s.student_name
ORDER BY avg_score DESC;

-- テストクエリ2：講座別の出席率
SELECT c.course_name, 
       COUNT(a.student_id) as total,
       SUM(CASE WHEN a.status = 'present' THEN 1 ELSE 0 END) as present,
       ROUND(AVG(CASE WHEN a.status = 'present' THEN 100.0 ELSE 0 END), 2) as attendance_rate
FROM courses c
JOIN course_schedule cs ON c.course_id = cs.course_id
LEFT JOIN attendance a ON cs.schedule_id = a.schedule_id
GROUP BY c.course_id, c.course_name
ORDER BY attendance_rate DESC;

-- プロファイリング結果の確認
SHOW PROFILES;
SHOW PROFILE FOR QUERY 1;
SHOW PROFILE FOR QUERY 2;
```

## インデックス設計のベストプラクティス

### 1. 選択性の高いカラムを優先

```sql
-- 良い例：選択性の高いカラム
CREATE INDEX idx_students_id ON students (student_id);  -- 一意性が高い

-- 注意が必要：選択性の低いカラム
CREATE INDEX idx_attendance_status ON attendance (status);  -- 3種類の値のみ
```

### 2. よく使用されるWHERE句の条件

```sql
-- アプリケーションでよく使用されるクエリを分析
-- 例：学生ポータルでの成績検索
SELECT * FROM grades 
WHERE student_id = ? AND course_id = ?;

-- 対応するインデックス
CREATE INDEX idx_grades_student_course ON grades (student_id, course_id);
```

### 3. ORDER BY句の最適化

```sql
-- ソートが必要なクエリ
SELECT * FROM grades 
WHERE course_id = '1'
ORDER BY score DESC;

-- ソート用インデックス
CREATE INDEX idx_grades_course_score_desc ON grades (course_id, score DESC);
```

### 4. カバリングインデックス

```sql
-- 必要なすべてのカラムを含むインデックス
CREATE INDEX idx_grades_covering 
ON grades (student_id, course_id, grade_type, score, submission_date);

-- このインデックスにより、テーブルアクセスなしで結果を取得可能
SELECT student_id, course_id, grade_type, score, submission_date
FROM grades
WHERE student_id = 301;
```

## 練習問題

### 問題31-1
以下のクエリを高速化するために必要なインデックスを特定し、CREATE INDEX文を書いてください：
```sql
SELECT * FROM students WHERE student_name LIKE '田%';
```

### 問題31-2
以下のクエリのパフォーマンスを向上させるための複合インデックスを設計してください：
```sql
SELECT * FROM grades 
WHERE course_id = '1' AND grade_type = '中間テスト' AND score >= 80
ORDER BY score DESC;
```

### 問題31-3
以下の結合クエリを最適化するために必要なインデックスをすべて特定してください：
```sql
SELECT s.student_name, c.course_name, g.score
FROM students s
JOIN student_courses sc ON s.student_id = sc.student_id
JOIN courses c ON sc.course_id = c.course_id
JOIN grades g ON s.student_id = g.student_id AND c.course_id = g.course_id
WHERE s.student_id BETWEEN 301 AND 310;
```

### 問題31-4
出席テーブル（attendance）で以下のクエリパターンが頻繁に実行されます。最適な複合インデックスを1つ設計してください：
- `WHERE schedule_id = ? AND student_id = ?`
- `WHERE schedule_id = ? AND status = 'present'`
- `WHERE schedule_id = ?`

### 問題31-5
EXPLAIN文を使用して、以下のクエリの実行計画を分析し、必要なインデックスを提案してください：
```sql
SELECT DATE_FORMAT(cs.schedule_date, '%Y-%m') as month,
       COUNT(*) as class_count,
       AVG(CASE WHEN a.status = 'present' THEN 1 ELSE 0 END) as attendance_rate
FROM course_schedule cs
LEFT JOIN attendance a ON cs.schedule_id = a.schedule_id
WHERE cs.schedule_date >= '2025-01-01'
GROUP BY DATE_FORMAT(cs.schedule_date, '%Y-%m');
```

### 問題31-6
以下の条件で、不要なインデックスを特定し、その理由を説明してください：
- gradesテーブルのmax_scoreカラム（ほとんどの値が100）
- studentsテーブルの非常に長いコメントカラム
- 頻繁に更新されるlast_updated_atカラム

## 解答

### 解答31-1
```sql
-- 前方一致検索用のインデックス
CREATE INDEX idx_students_name ON students (student_name);

-- LIKE '田%' のような前方一致検索では、このインデックスが効果的に使用される
-- ただし、'%田%' のような中間一致や '%田' のような後方一致では効果的でない
```

### 解答31-2
```sql
-- 複合インデックスの設計
-- WHERE句の条件とORDER BY句を考慮
CREATE INDEX idx_grades_course_type_score_desc 
ON grades (course_id, grade_type, score DESC);

-- このインデックスにより：
-- 1. course_id = '1' での絞り込み
-- 2. grade_type = '中間テスト' での絞り込み  
-- 3. score >= 80 での範囲検索
-- 4. score DESC でのソート
-- すべてが効率的に実行される
```

### 解答31-3
```sql
-- 必要なインデックス一覧

-- 1. students テーブル（主キーは既存）
-- student_id は主キーなので既にインデックスあり

-- 2. student_courses テーブル
CREATE INDEX idx_student_courses_student ON student_courses (student_id);
CREATE INDEX idx_student_courses_course ON student_courses (course_id);

-- 3. courses テーブル（主キーは既存）
-- course_id は主キーなので既にインデックスあり

-- 4. grades テーブル
CREATE INDEX idx_grades_student ON grades (student_id);
CREATE INDEX idx_grades_course ON grades (course_id);
-- または結合用の複合インデックス
CREATE INDEX idx_grades_student_course ON grades (student_id, course_id);

-- 5. WHERE句の条件用
-- student_id BETWEEN 301 AND 310 は主キーで効率的に処理される
```

### 解答31-4
```sql
-- 最適な複合インデックス
CREATE INDEX idx_attendance_schedule_student_status 
ON attendance (schedule_id, student_id, status);

-- このインデックスが3つのクエリパターンすべてに対応：
-- 1. WHERE schedule_id = ? AND student_id = ? （左端から2カラム使用）
-- 2. WHERE schedule_id = ? AND status = 'present' （schedule_idと3番目のstatusを使用）
-- 3. WHERE schedule_id = ? （左端カラムのみ使用）

-- 左端一致の原則により、すべてのパターンで効果的に使用される
```

### 解答31-5
```sql
-- まず現在の実行計画を確認
EXPLAIN FORMAT=JSON
SELECT DATE_FORMAT(cs.schedule_date, '%Y-%m') as month,
       COUNT(*) as class_count,
       AVG(CASE WHEN a.status = 'present' THEN 1 ELSE 0 END) as attendance_rate
FROM course_schedule cs
LEFT JOIN attendance a ON cs.schedule_id = a.schedule_id
WHERE cs.schedule_date >= '2025-01-01'
GROUP BY DATE_FORMAT(cs.schedule_date, '%Y-%m');

-- 必要なインデックス
-- 1. WHERE句の条件用
CREATE INDEX idx_schedule_date ON course_schedule (schedule_date);

-- 2. LEFT JOIN用
CREATE INDEX idx_attendance_schedule ON attendance (schedule_id);

-- 3. 集計処理最適化用（オプション）
CREATE INDEX idx_attendance_schedule_status ON attendance (schedule_id, status);

-- これらのインデックスにより：
-- - WHERE句での日付範囲検索が高速化
-- - LEFT JOINが効率的に実行
-- - GROUP BYとAVG計算が最適化
```

### 解答31-6
```sql
-- 不要または注意が必要なインデックス

-- 1. gradesテーブルのmax_scoreカラム
-- DROP INDEX idx_grades_max_score ON grades;
-- 理由：選択性が非常に低い（ほとんどの値が100）
-- ほとんどの行が同じ値を持つため、インデックスの効果が薄い

-- 2. studentsテーブルの長いコメントカラム
-- DROP INDEX idx_students_comment ON students;  
-- 理由：長いテキストフィールドのインデックスは容量を大量消費
-- 前方一致検索以外では効果的でない

-- 3. 頻繁に更新されるlast_updated_atカラム
-- DROP INDEX idx_last_updated ON some_table;
-- 理由：頻繁な更新によりインデックスメンテナンスコストが高い
-- 更新のたびにインデックスの再構築が必要

-- 代替案：
-- - 選択性の高いカラムと組み合わせた複合インデックス
-- - 部分インデックス（特定条件のみ）
-- - 更新頻度とクエリ頻度を比較して判断
```

## まとめ

この章では、インデックスについて詳しく学びました：

1. **インデックスの基本概念**：
   - データベースの索引としての役割
   - B-Treeインデックスの仕組み
   - パフォーマンス向上の原理

2. **インデックスの種類**：
   - 主キーインデックス（自動作成）
   - 一意インデックス
   - 単一カラムインデックス
   - 複合インデックス

3. **効果的なインデックス設計**：
   - WHERE句で使用されるカラム
   - ORDER BY句で使用されるカラム
   - JOIN条件で使用されるカラム
   - 左端一致の原則

4. **パフォーマンス分析**：
   - EXPLAIN文による実行計画の確認
   - インデックス使用状況の監視
   - クエリ最適化の手法

5. **インデックスのコスト**：
   - 挿入・更新・削除への影響
   - ストレージ使用量の増加
   - メンテナンスコスト

6. **実践的な設計例**：
   - 学校データベースでの具体例
   - クエリパターンの分析
   - 包括的なインデックス戦略

7. **ベストプラクティス**：
   - 選択性の高いカラムの優先
   - カバリングインデックスの活用
   - 不要なインデックスの削除

8. **保守と最適化**：
   - インデックスの確認方法
   - 再構築とメンテナンス
   - パフォーマンス監視

インデックスは、データベースパフォーマンスの最も重要な要素の一つです。適切に設計・管理することで、アプリケーションの応答性を大幅に改善できます。ただし、過度なインデックス作成はかえってパフォーマンスを悪化させる可能性があるため、バランスの取れた設計が重要です。

これで第5章「データ操作と管理」が完了しました。INSERT、UPDATE、DELETE文によるデータ操作から、トランザクション、ビュー、インデックスまで、データベース管理の重要な技術を体系的に学習できました。

------------------------------------------------------------

